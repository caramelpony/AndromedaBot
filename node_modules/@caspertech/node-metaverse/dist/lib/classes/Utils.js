"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
const Long = require("long");
const rxjs_1 = require("rxjs");
const xml2js = require("xml2js");
const zlib = require("zlib");
const AssetType_1 = require("../enums/AssetType");
const FilterResponse_1 = require("../enums/FilterResponse");
const HTTPAssets_1 = require("../enums/HTTPAssets");
const InventoryType_1 = require("../enums/InventoryType");
const Logger_1 = require("./Logger");
const Quaternion_1 = require("./Quaternion");
const Vector3_1 = require("./Vector3");
const crypto = require("crypto");
class Utils {
    static StringToBuffer(str) {
        return Buffer.from(str + '\0', 'utf8');
    }
    static SHA1String(str) {
        return crypto.createHash('sha1').update(str).digest('hex');
    }
    static BufferToStringSimple(buf) {
        if (buf.length === 0) {
            return '';
        }
        if (buf[buf.length - 1] === 0) {
            return buf.slice(0, buf.length - 1).toString('utf8');
        }
        else {
            return buf.toString('utf8');
        }
    }
    static Clamp(value, min, max) {
        value = (value > max) ? max : value;
        value = (value < min) ? min : value;
        return value;
    }
    static fillArray(value, count) {
        const arr = new Array(count);
        while (count--) {
            arr[count] = value;
        }
        return arr;
    }
    static JSONStringify(obj, space) {
        const cache = [];
        return JSON.stringify(obj, function (_, value) {
            if (typeof value === 'object' && value !== null) {
                if (cache.indexOf(value) !== -1) {
                    try {
                        return JSON.parse(JSON.stringify(value));
                    }
                    catch (error) {
                        return 'Circular Reference';
                    }
                }
                cache.push(value);
            }
            return value;
        }, space);
    }
    static BufferToString(buf, startPos) {
        if (buf.length === 0) {
            return {
                readLength: 0,
                result: ''
            };
        }
        if (startPos === undefined) {
            startPos = 0;
        }
        let foundNull = -1;
        for (let x = startPos; x <= buf.length; x++) {
            if (buf[x] === 0) {
                foundNull = x;
                break;
            }
        }
        if (foundNull === -1) {
            console.error('BufferToString: Null terminator not found after ' + (buf.length - startPos) + ' bytes. Buffer length: ' + buf.length + ', startPos: ' + startPos);
            foundNull = buf.length - 1;
        }
        return {
            readLength: (foundNull - startPos) + 1,
            result: buf.slice(startPos, foundNull).toString('utf8')
        };
    }
    static RegionCoordinatesToHandle(regionX, regionY) {
        const realRegionX = Math.floor(regionX / 256) * 256;
        const realRegionY = Math.floor(regionY / 256) * 256;
        const localX = regionX - realRegionX;
        const localY = regionY - realRegionY;
        const handle = new Long(realRegionY, realRegionX);
        return {
            'regionHandle': handle,
            'regionX': realRegionX / 256,
            'regionY': realRegionY / 256,
            'localX': localX,
            'localY': localY
        };
    }
    static InventoryTypeToLLInventoryType(type) {
        switch (type) {
            case InventoryType_1.InventoryType.Texture:
                return 'texture';
            case InventoryType_1.InventoryType.Sound:
                return 'sound';
            case InventoryType_1.InventoryType.CallingCard:
                return 'callcard';
            case InventoryType_1.InventoryType.Landmark:
                return 'landmark';
            case InventoryType_1.InventoryType.Object:
                return 'object';
            case InventoryType_1.InventoryType.Notecard:
                return 'notecard';
            case InventoryType_1.InventoryType.Category:
                return 'category';
            case InventoryType_1.InventoryType.RootCategory:
                return 'root';
            case InventoryType_1.InventoryType.Script:
                return 'script';
            case InventoryType_1.InventoryType.Snapshot:
                return 'snapshot';
            case InventoryType_1.InventoryType.Attachment:
                return 'attach';
            case InventoryType_1.InventoryType.Bodypart:
                return 'bodypart';
            case InventoryType_1.InventoryType.Wearable:
                return 'wearable';
            case InventoryType_1.InventoryType.Animation:
                return 'animation';
            case InventoryType_1.InventoryType.Gesture:
                return 'gesture';
            case InventoryType_1.InventoryType.Mesh:
                return 'mesh';
            case InventoryType_1.InventoryType.LSL:
                return 'script';
            case InventoryType_1.InventoryType.Widget:
                return 'widget';
            case InventoryType_1.InventoryType.Person:
                return 'person';
            case InventoryType_1.InventoryType.Settings:
                return 'settings';
            default:
                console.error('Unknown inventory type: ' + InventoryType_1.InventoryType[type]);
                return 'texture';
        }
    }
    static HTTPAssetTypeToAssetType(HTTPAssetType) {
        switch (HTTPAssetType) {
            case HTTPAssets_1.HTTPAssets.ASSET_TEXTURE:
                return AssetType_1.AssetType.Texture;
            case HTTPAssets_1.HTTPAssets.ASSET_SOUND:
                return AssetType_1.AssetType.Sound;
            case HTTPAssets_1.HTTPAssets.ASSET_ANIMATION:
                return AssetType_1.AssetType.Animation;
            case HTTPAssets_1.HTTPAssets.ASSET_GESTURE:
                return AssetType_1.AssetType.Gesture;
            case HTTPAssets_1.HTTPAssets.ASSET_LANDMARK:
                return AssetType_1.AssetType.Landmark;
            case HTTPAssets_1.HTTPAssets.ASSET_CALLINGCARD:
                return AssetType_1.AssetType.CallingCard;
            case HTTPAssets_1.HTTPAssets.ASSET_SCRIPT:
                return AssetType_1.AssetType.Script;
            case HTTPAssets_1.HTTPAssets.ASSET_CLOTHING:
                return AssetType_1.AssetType.Clothing;
            case HTTPAssets_1.HTTPAssets.ASSET_OBJECT:
                return AssetType_1.AssetType.Object;
            case HTTPAssets_1.HTTPAssets.ASSET_NOTECARD:
                return AssetType_1.AssetType.Notecard;
            case HTTPAssets_1.HTTPAssets.ASSET_LSL_TEXT:
                return AssetType_1.AssetType.LSLText;
            case HTTPAssets_1.HTTPAssets.ASSET_LSL_BYTECODE:
                return AssetType_1.AssetType.LSLBytecode;
            case HTTPAssets_1.HTTPAssets.ASSET_BODYPART:
                return AssetType_1.AssetType.Bodypart;
            case HTTPAssets_1.HTTPAssets.ASSET_MESH:
                return AssetType_1.AssetType.Mesh;
            case HTTPAssets_1.HTTPAssets.ASSET_SETTINGS:
                return AssetType_1.AssetType.Settings;
            case HTTPAssets_1.HTTPAssets.ASSET_WIDGET:
                return AssetType_1.AssetType.Widget;
            case HTTPAssets_1.HTTPAssets.ASSET_PERSON:
                return AssetType_1.AssetType.Person;
            default:
                return 0;
        }
    }
    static AssetTypeToHTTPAssetType(assetType) {
        switch (assetType) {
            case AssetType_1.AssetType.Texture:
                return HTTPAssets_1.HTTPAssets.ASSET_TEXTURE;
            case AssetType_1.AssetType.Sound:
                return HTTPAssets_1.HTTPAssets.ASSET_SOUND;
            case AssetType_1.AssetType.Animation:
                return HTTPAssets_1.HTTPAssets.ASSET_ANIMATION;
            case AssetType_1.AssetType.Gesture:
                return HTTPAssets_1.HTTPAssets.ASSET_GESTURE;
            case AssetType_1.AssetType.Landmark:
                return HTTPAssets_1.HTTPAssets.ASSET_LANDMARK;
            case AssetType_1.AssetType.CallingCard:
                return HTTPAssets_1.HTTPAssets.ASSET_CALLINGCARD;
            case AssetType_1.AssetType.Script:
                return HTTPAssets_1.HTTPAssets.ASSET_SCRIPT;
            case AssetType_1.AssetType.Clothing:
                return HTTPAssets_1.HTTPAssets.ASSET_CLOTHING;
            case AssetType_1.AssetType.Object:
                return HTTPAssets_1.HTTPAssets.ASSET_OBJECT;
            case AssetType_1.AssetType.Notecard:
                return HTTPAssets_1.HTTPAssets.ASSET_NOTECARD;
            case AssetType_1.AssetType.LSLText:
                return HTTPAssets_1.HTTPAssets.ASSET_LSL_TEXT;
            case AssetType_1.AssetType.LSLBytecode:
                return HTTPAssets_1.HTTPAssets.ASSET_LSL_BYTECODE;
            case AssetType_1.AssetType.Bodypart:
                return HTTPAssets_1.HTTPAssets.ASSET_BODYPART;
            case AssetType_1.AssetType.Mesh:
                return HTTPAssets_1.HTTPAssets.ASSET_MESH;
            case AssetType_1.AssetType.Settings:
                return HTTPAssets_1.HTTPAssets.ASSET_SETTINGS;
            case AssetType_1.AssetType.Person:
                return HTTPAssets_1.HTTPAssets.ASSET_PERSON;
            case AssetType_1.AssetType.Widget:
                return HTTPAssets_1.HTTPAssets.ASSET_WIDGET;
            default:
                return HTTPAssets_1.HTTPAssets.ASSET_TEXTURE;
        }
    }
    static HTTPAssetTypeToInventoryType(HTTPAssetType) {
        switch (HTTPAssetType) {
            case HTTPAssets_1.HTTPAssets.ASSET_TEXTURE:
                return InventoryType_1.InventoryType.Texture;
            case HTTPAssets_1.HTTPAssets.ASSET_SOUND:
                return InventoryType_1.InventoryType.Sound;
            case HTTPAssets_1.HTTPAssets.ASSET_ANIMATION:
                return InventoryType_1.InventoryType.Animation;
            case HTTPAssets_1.HTTPAssets.ASSET_GESTURE:
                return InventoryType_1.InventoryType.Gesture;
            case HTTPAssets_1.HTTPAssets.ASSET_LANDMARK:
                return InventoryType_1.InventoryType.Landmark;
            case HTTPAssets_1.HTTPAssets.ASSET_CALLINGCARD:
                return InventoryType_1.InventoryType.CallingCard;
            case HTTPAssets_1.HTTPAssets.ASSET_SCRIPT:
                return InventoryType_1.InventoryType.LSL;
            case HTTPAssets_1.HTTPAssets.ASSET_CLOTHING:
                return InventoryType_1.InventoryType.Wearable;
            case HTTPAssets_1.HTTPAssets.ASSET_OBJECT:
                return InventoryType_1.InventoryType.Object;
            case HTTPAssets_1.HTTPAssets.ASSET_NOTECARD:
                return InventoryType_1.InventoryType.Notecard;
            case HTTPAssets_1.HTTPAssets.ASSET_LSL_TEXT:
                return InventoryType_1.InventoryType.LSL;
            case HTTPAssets_1.HTTPAssets.ASSET_LSL_BYTECODE:
                return InventoryType_1.InventoryType.LSL;
            case HTTPAssets_1.HTTPAssets.ASSET_BODYPART:
                return InventoryType_1.InventoryType.Wearable;
            case HTTPAssets_1.HTTPAssets.ASSET_MESH:
                return InventoryType_1.InventoryType.Mesh;
            default:
                return 0;
        }
    }
    static HTTPAssetTypeToCapInventoryType(HTTPAssetType) {
        switch (HTTPAssetType) {
            case HTTPAssets_1.HTTPAssets.ASSET_TEXTURE:
                return 'texture';
            case HTTPAssets_1.HTTPAssets.ASSET_SOUND:
                return 'sound';
            case HTTPAssets_1.HTTPAssets.ASSET_ANIMATION:
                return 'animation';
            case HTTPAssets_1.HTTPAssets.ASSET_GESTURE:
                return 'gesture';
            case HTTPAssets_1.HTTPAssets.ASSET_LANDMARK:
                return 'landmark';
            case HTTPAssets_1.HTTPAssets.ASSET_CALLINGCARD:
                return 'callcard';
            case HTTPAssets_1.HTTPAssets.ASSET_SCRIPT:
                return 'script';
            case HTTPAssets_1.HTTPAssets.ASSET_CLOTHING:
                return 'wearable';
            case HTTPAssets_1.HTTPAssets.ASSET_OBJECT:
                return 'object';
            case HTTPAssets_1.HTTPAssets.ASSET_NOTECARD:
                return 'notecard';
            case HTTPAssets_1.HTTPAssets.ASSET_CATEGORY:
                return 'category';
            case HTTPAssets_1.HTTPAssets.ASSET_LSL_TEXT:
                return 'script';
            case HTTPAssets_1.HTTPAssets.ASSET_LSL_BYTECODE:
                return 'script';
            case HTTPAssets_1.HTTPAssets.ASSET_BODYPART:
                return 'wearable';
            case HTTPAssets_1.HTTPAssets.ASSET_MESH:
                return 'mesh';
            default:
                return '';
        }
    }
    static FloatToByte(val, lower, upper) {
        val = Utils.Clamp(val, lower, upper);
        val -= lower;
        val /= (upper - lower);
        return Math.round(val * 255);
    }
    static ByteToFloat(byte, lower, upper) {
        const ONE_OVER_BYTEMAX = 1.0 / 255;
        let fval = byte * ONE_OVER_BYTEMAX;
        const delta = (upper - lower);
        fval *= delta;
        fval += lower;
        const error = delta * ONE_OVER_BYTEMAX;
        if (Math.abs(fval) < error) {
            fval = 0.0;
        }
        return fval;
    }
    static UInt16ToFloat(val, lower, upper) {
        const ONE_OVER_U16_MAX = 1.0 / 65535;
        let fval = val * ONE_OVER_U16_MAX;
        const delta = upper - lower;
        fval *= delta;
        fval += lower;
        const maxError = delta * ONE_OVER_U16_MAX;
        if (Math.abs(fval) < maxError) {
            fval = 0.0;
        }
        return fval;
    }
    static Base64EncodeString(str) {
        const buff = Buffer.from(str, 'utf8');
        return buff.toString('base64');
    }
    static Base64DecodeString(str) {
        const buff = Buffer.from(str, 'base64');
        return buff.toString('utf8');
    }
    static HexToLong(hex) {
        while (hex.length < 16) {
            hex = '0' + hex;
        }
        return new Long(parseInt(hex.substr(8), 16), parseInt(hex.substr(0, 8), 16));
    }
    static ReadRotationFloat(buf, pos) {
        return ((buf[pos] | (buf[pos + 1] << 8)) / 32768.0) * Utils.TWO_PI;
    }
    static ReadGlowFloat(buf, pos) {
        return buf[pos] / 255;
    }
    static ReadOffsetFloat(buf, pos) {
        const offset = buf.readInt16LE(pos);
        return offset / 32767.0;
    }
    static TEOffsetShort(num) {
        num = Utils.Clamp(num, -1.0, 1.0);
        num *= 32767.0;
        return Math.round(num);
    }
    static IEEERemainder(x, y) {
        if (isNaN(x)) {
            return x; // IEEE 754-2008: NaN payload must be preserved
        }
        if (isNaN(y)) {
            return y; // IEEE 754-2008: NaN payload must be preserved
        }
        const regularMod = x % y;
        if (isNaN(regularMod)) {
            return NaN;
        }
        if (regularMod === 0) {
            if (Math.sign(x) < 0) {
                return -0;
            }
        }
        const alternativeResult = regularMod - (Math.abs(y) * Math.sign(x));
        if (Math.abs(alternativeResult) === Math.abs(regularMod)) {
            const divisionResult = x / y;
            const roundedResult = Math.round(divisionResult);
            if (Math.abs(roundedResult) > Math.abs(divisionResult)) {
                return alternativeResult;
            }
            else {
                return regularMod;
            }
        }
        if (Math.abs(alternativeResult) < Math.abs(regularMod)) {
            return alternativeResult;
        }
        else {
            return regularMod;
        }
    }
    static TERotationShort(rotation) {
        return Math.floor(((Utils.IEEERemainder(rotation, Utils.TWO_PI) / Utils.TWO_PI) * 32768.0) + 0.5);
    }
    static OctetsToUInt32BE(octets) {
        const buf = Buffer.allocUnsafe(4);
        let pos = 0;
        for (let x = octets.length - 4; x < octets.length; x++) {
            if (x >= 0) {
                buf.writeUInt8(octets[x], pos++);
            }
            else {
                pos++;
            }
        }
        return buf.readUInt32BE(0);
    }
    static OctetsToUInt32LE(octets) {
        const buf = Buffer.allocUnsafe(4);
        let pos = 0;
        for (let x = octets.length - 4; x < octets.length; x++) {
            if (x >= 0) {
                buf.writeUInt8(octets[x], pos++);
            }
            else {
                pos++;
            }
        }
        return buf.readUInt32LE(0);
    }
    static numberToFixedHex(num) {
        let str = num.toString(16);
        while (str.length < 8) {
            str = '0' + str;
        }
        return str;
    }
    static TEGlowByte(glow) {
        return (glow * 255.0);
    }
    static NumberToByteBuffer(num) {
        const buf = Buffer.allocUnsafe(1);
        buf.writeUInt8(num, 0);
        return buf;
    }
    static NumberToShortBuffer(num) {
        const buf = Buffer.allocUnsafe(2);
        buf.writeInt16LE(num, 0);
        return buf;
    }
    static NumberToFloatBuffer(num) {
        const buf = Buffer.allocUnsafe(4);
        buf.writeFloatLE(num, 0);
        return buf;
    }
    static numberOrZero(num) {
        if (num === undefined) {
            return 0;
        }
        return num;
    }
    static vector3OrZero(vec) {
        if (vec === undefined) {
            return Vector3_1.Vector3.getZero();
        }
        return vec;
    }
    static quaternionOrZero(quat) {
        if (quat === undefined) {
            return Quaternion_1.Quaternion.getIdentity();
        }
        return quat;
    }
    static packBeginCut(beginCut) {
        return Math.round(beginCut / Utils.CUT_QUANTA);
    }
    static packEndCut(endCut) {
        return (50000 - Math.round(endCut / Utils.CUT_QUANTA));
    }
    static packPathScale(pathScale) {
        return (200 - Math.round(pathScale / Utils.SCALE_QUANTA));
    }
    static packPathShear(pathShear) {
        return Math.round(pathShear / Utils.SHEAR_QUANTA);
    }
    static packPathTwist(pathTwist) {
        return Math.round(pathTwist / Utils.SCALE_QUANTA);
    }
    static packPathTaper(pathTaper) {
        return Math.round(pathTaper / Utils.TAPER_QUANTA);
    }
    static packPathRevolutions(pathRevolutions) {
        return Math.round((pathRevolutions - 1) / Utils.REV_QUANTA);
    }
    static packProfileHollow(profileHollow) {
        return Math.round(profileHollow / Utils.HOLLOW_QUANTA);
    }
    static unpackBeginCut(beginCut) {
        return beginCut * Utils.CUT_QUANTA;
    }
    static unpackEndCut(endCut) {
        return (50000 - endCut) * Utils.CUT_QUANTA;
    }
    static unpackPathScale(pathScale) {
        return (200 - pathScale) * Utils.SCALE_QUANTA;
    }
    static unpackPathShear(pathShear) {
        return pathShear * Utils.SHEAR_QUANTA;
    }
    static unpackPathTwist(pathTwist) {
        return pathTwist * Utils.SCALE_QUANTA;
    }
    static unpackPathTaper(pathTaper) {
        return pathTaper * Utils.TAPER_QUANTA;
    }
    static unpackPathRevolutions(pathRevolutions) {
        return pathRevolutions * Utils.REV_QUANTA + 1;
    }
    static unpackProfileHollow(profileHollow) {
        return profileHollow * Utils.HOLLOW_QUANTA;
    }
    static nullTerminatedString(str) {
        const index = str.indexOf('\0');
        if (index === -1) {
            return str;
        }
        else {
            return str.substr(0, index - 1);
        }
    }
    static promiseConcurrent(promises, concurrency, timeout) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const originalConcurrency = concurrency;
            const promiseQueue = [];
            Logger_1.Logger.Info('PromiseConcurrent: ' + promiseQueue.length + ' in queue. Concurrency: ' + concurrency);
            for (const promise of promises) {
                promiseQueue.push(promise);
            }
            const slotAvailable = new rxjs_1.Subject();
            const errors = [];
            const results = [];
            function waitForAvailable() {
                return new Promise((resolve1) => {
                    const subs = slotAvailable.subscribe(() => {
                        subs.unsubscribe();
                        resolve1();
                    });
                });
            }
            function runPromise(promise) {
                concurrency--;
                let timedOut = false;
                let timeo = undefined;
                promise().then((result) => {
                    if (timedOut) {
                        return;
                    }
                    if (timeo !== undefined) {
                        clearTimeout(timeo);
                    }
                    results.push(result);
                    concurrency++;
                    slotAvailable.next();
                }).catch((err) => {
                    if (timedOut) {
                        return;
                    }
                    if (timeo !== undefined) {
                        clearTimeout(timeo);
                    }
                    errors.push(err);
                    concurrency++;
                    slotAvailable.next();
                });
                if (timeout > 0) {
                    timeo = setTimeout(() => {
                        timedOut = true;
                        errors.push(new Error('Promise timed out'));
                        concurrency++;
                        slotAvailable.next();
                    }, timeout);
                }
            }
            while (promiseQueue.length > 0) {
                if (concurrency < 1) {
                    yield waitForAvailable();
                }
                else {
                    const thunk = promiseQueue.shift();
                    if (thunk !== undefined) {
                        runPromise(thunk);
                    }
                }
            }
            while (concurrency < originalConcurrency) {
                yield waitForAvailable();
            }
            resolve({ results: results, errors: errors });
        }));
    }
    static waitFor(timeout) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, timeout);
        });
    }
    static getFromXMLJS(obj, param) {
        if (obj[param] === undefined) {
            return undefined;
        }
        let retParam;
        if (Array.isArray(obj[param])) {
            retParam = obj[param][0];
        }
        else {
            retParam = obj[param];
        }
        if (typeof retParam === 'string') {
            if (retParam.toLowerCase() === 'false') {
                return false;
            }
            if (retParam.toLowerCase() === 'true') {
                return true;
            }
            const numVar = parseInt(retParam, 10);
            if (numVar >= Number.MIN_SAFE_INTEGER && numVar <= Number.MAX_SAFE_INTEGER && String(numVar) === retParam) {
                return numVar;
            }
        }
        return retParam;
    }
    static inflate(buf) {
        return new Promise((resolve, reject) => {
            zlib.inflate(buf, (error, result) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            });
        });
    }
    static deflate(buf) {
        return new Promise((resolve, reject) => {
            zlib.deflate(buf, { level: 9 }, (error, result) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            });
        });
    }
    static waitOrTimeOut(subject, timeout, callback) {
        return new Promise((resolve, reject) => {
            let timer = undefined;
            let subs = undefined;
            subs = subject.subscribe((result) => {
                if (callback !== undefined) {
                    const accepted = callback(result);
                    if (accepted !== FilterResponse_1.FilterResponse.Finish) {
                        return;
                    }
                }
                if (timer !== undefined) {
                    clearTimeout(timer);
                    timer = undefined;
                }
                if (subs !== undefined) {
                    subs.unsubscribe();
                    subs = undefined;
                }
                resolve(result);
            });
            if (timeout !== undefined) {
                timer = setTimeout(() => {
                    if (timer !== undefined) {
                        clearTimeout(timer);
                        timer = undefined;
                    }
                    if (subs !== undefined) {
                        subs.unsubscribe();
                        subs = undefined;
                    }
                    reject(new Error('Timeout'));
                }, timeout);
            }
        });
    }
    static parseLine(line) {
        line = line.trim().replace(/[\t]/gu, ' ').trim();
        while (line.indexOf('\u0020\u0020') > 0) {
            line = line.replace(/\u0020\u0020/gu, '\u0020');
        }
        let key = null;
        let value = '';
        if (line.length > 2) {
            const sep = line.indexOf(' ');
            if (sep > 0) {
                key = line.substr(0, sep);
                value = line.substr(sep + 1);
            }
        }
        else if (line.length === 1) {
            key = line;
        }
        else if (line.length > 0) {
            return {
                'key': line,
                'value': ''
            };
        }
        if (key !== null) {
            key = key.trim();
        }
        return {
            'key': key,
            'value': value
        };
    }
    static sanitizePath(input) {
        return input.replace(/[^a-z0-9]/gi, '').replace(/ /gi, '_');
    }
    static parseXML(input) {
        return new Promise((resolve, reject) => {
            xml2js.parseString(input, (err, result) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(result);
                }
            });
        });
    }
}
exports.Utils = Utils;
Utils.TWO_PI = 6.283185307179586476925286766559;
Utils.CUT_QUANTA = 0.00002;
Utils.SCALE_QUANTA = 0.01;
Utils.SHEAR_QUANTA = 0.01;
Utils.TAPER_QUANTA = 0.01;
Utils.REV_QUANTA = 0.015;
Utils.HOLLOW_QUANTA = 0.00002;
//# sourceMappingURL=Utils.js.map