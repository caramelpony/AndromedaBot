/// <reference types="node" />
import * as Long from 'long';
import { Subject } from 'rxjs';
import { AssetType } from '../enums/AssetType';
import { FilterResponse } from '../enums/FilterResponse';
import { HTTPAssets } from '../enums/HTTPAssets';
import { InventoryType } from '../enums/InventoryType';
import { GlobalPosition } from './public/interfaces/GlobalPosition';
import { Quaternion } from './Quaternion';
import { Vector3 } from './Vector3';
export declare class Utils {
    static TWO_PI: number;
    static CUT_QUANTA: number;
    static SCALE_QUANTA: number;
    static SHEAR_QUANTA: number;
    static TAPER_QUANTA: number;
    static REV_QUANTA: number;
    static HOLLOW_QUANTA: number;
    static StringToBuffer(str: string): Buffer;
    static SHA1String(str: string): string;
    static BufferToStringSimple(buf: Buffer): string;
    static Clamp(value: number, min: number, max: number): number;
    static fillArray<T>(value: T, count: number): T[];
    static JSONStringify(obj: object, space: number): string;
    static BufferToString(buf: Buffer, startPos?: number): {
        readLength: number;
        result: string;
    };
    static RegionCoordinatesToHandle(regionX: number, regionY: number): GlobalPosition;
    static InventoryTypeToLLInventoryType(type: InventoryType): string;
    static HTTPAssetTypeToAssetType(HTTPAssetType: string): AssetType;
    static AssetTypeToHTTPAssetType(assetType: AssetType): HTTPAssets;
    static HTTPAssetTypeToInventoryType(HTTPAssetType: string): InventoryType;
    static HTTPAssetTypeToCapInventoryType(HTTPAssetType: string): String;
    static FloatToByte(val: number, lower: number, upper: number): number;
    static ByteToFloat(byte: number, lower: number, upper: number): number;
    static UInt16ToFloat(val: number, lower: number, upper: number): number;
    static Base64EncodeString(str: string): string;
    static Base64DecodeString(str: string): string;
    static HexToLong(hex: string): Long;
    static ReadRotationFloat(buf: Buffer, pos: number): number;
    static ReadGlowFloat(buf: Buffer, pos: number): number;
    static ReadOffsetFloat(buf: Buffer, pos: number): number;
    static TEOffsetShort(num: number): number;
    static IEEERemainder(x: number, y: number): number;
    static TERotationShort(rotation: number): number;
    static OctetsToUInt32BE(octets: number[]): number;
    static OctetsToUInt32LE(octets: number[]): number;
    static numberToFixedHex(num: number): string;
    static TEGlowByte(glow: number): number;
    static NumberToByteBuffer(num: number): Buffer;
    static NumberToShortBuffer(num: number): Buffer;
    static NumberToFloatBuffer(num: number): Buffer;
    static numberOrZero(num: number | undefined): number;
    static vector3OrZero(vec: Vector3 | undefined): Vector3;
    static quaternionOrZero(quat: Quaternion | undefined): Quaternion;
    static packBeginCut(beginCut: number): number;
    static packEndCut(endCut: number): number;
    static packPathScale(pathScale: number): number;
    static packPathShear(pathShear: number): number;
    static packPathTwist(pathTwist: number): number;
    static packPathTaper(pathTaper: number): number;
    static packPathRevolutions(pathRevolutions: number): number;
    static packProfileHollow(profileHollow: number): number;
    static unpackBeginCut(beginCut: number): number;
    static unpackEndCut(endCut: number): number;
    static unpackPathScale(pathScale: number): number;
    static unpackPathShear(pathShear: number): number;
    static unpackPathTwist(pathTwist: number): number;
    static unpackPathTaper(pathTaper: number): number;
    static unpackPathRevolutions(pathRevolutions: number): number;
    static unpackProfileHollow(profileHollow: number): number;
    static nullTerminatedString(str: string): string;
    static promiseConcurrent<T>(promises: (() => Promise<T>)[], concurrency: number, timeout: number): Promise<{
        results: T[];
        errors: Error[];
    }>;
    static waitFor(timeout: number): Promise<void>;
    static getFromXMLJS(obj: any, param: string): any;
    static inflate(buf: Buffer): Promise<Buffer>;
    static deflate(buf: Buffer): Promise<Buffer>;
    static waitOrTimeOut<T>(subject: Subject<T>, timeout?: number, callback?: (msg: T) => FilterResponse): Promise<T>;
    static parseLine(line: string): {
        'key': string | null;
        'value': string;
    };
    static sanitizePath(input: string): string;
    static parseXML(input: string): Promise<any>;
}
