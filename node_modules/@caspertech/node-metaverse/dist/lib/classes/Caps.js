"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Caps = void 0;
const EventQueueClient_1 = require("./EventQueueClient");
const rxjs_1 = require("rxjs");
const HTTPAssets_1 = require("../enums/HTTPAssets");
const LLSD = require("@caspertech/llsd");
const request = require("request");
const url = require("url");
class Caps {
    constructor(agent, seedURL, clientEvents) {
        this.onGotSeedCap = new rxjs_1.Subject();
        this.gotSeedCap = false;
        this.capabilities = {};
        this.active = false;
        this.timeLastCapExecuted = {};
        this.eventQueueClient = null;
        this.agent = agent;
        this.clientEvents = clientEvents;
        const req = [];
        req.push('AbuseCategories');
        req.push('AcceptFriendship');
        req.push('AcceptGroupInvite');
        req.push('AgentPreferences');
        req.push('AgentState');
        req.push('AttachmentResources');
        req.push('AvatarPickerSearch');
        req.push('AvatarRenderInfo');
        req.push('CharacterProperties');
        req.push('ChatSessionRequest');
        req.push('CopyInventoryFromNotecard');
        req.push('CreateInventoryCategory');
        req.push('DeclineFriendship');
        req.push('DeclineGroupInvite');
        req.push('DispatchRegionInfo');
        req.push('DirectDelivery');
        req.push('EnvironmentSettings');
        req.push('EstateAccess');
        req.push('EstateChangeInfo');
        req.push('EventQueueGet');
        req.push('ExtEnvironment');
        req.push('FetchLib2');
        req.push('FetchLibDescendents2');
        req.push('FetchInventory2');
        req.push('FetchInventoryDescendents2');
        req.push('IncrementCOFVersion');
        req.push('GetDisplayNames');
        req.push('GetExperiences');
        req.push('AgentExperiences');
        req.push('FindExperienceByName');
        req.push('GetExperienceInfo');
        req.push('GetAdminExperiences');
        req.push('GetCreatorExperiences');
        req.push('ExperiencePreferences');
        req.push('GroupExperiences');
        req.push('UpdateExperience');
        req.push('IsExperienceAdmin');
        req.push('IsExperienceContributor');
        req.push('InventoryAPIv3');
        req.push('RegionExperiences');
        req.push('ExperienceQuery');
        req.push('GetMetadata');
        req.push('GetObjectCost');
        req.push('GetObjectPhysicsData');
        req.push('GroupAPIv1');
        req.push('GroupMemberData');
        req.push('GroupProposalBallot');
        req.push('HomeLocation');
        req.push('LandResources');
        req.push('LSLSyntax');
        req.push('MapLayer');
        req.push('MapLayerGod');
        req.push('MeshUploadFlag');
        req.push('NavMeshGenerationStatus');
        req.push('NewFileAgentInventory');
        req.push('ObjectAnimation');
        req.push('ObjectMedia');
        req.push('ObjectMediaNavigate');
        req.push('ObjectNavMeshProperties');
        req.push('ParcelPropertiesUpdate');
        req.push('ParcelVoiceInfoRequest');
        req.push('ProductInfoRequest');
        req.push('ProvisionVoiceAccountRequest');
        req.push('ReadOfflineMsgs');
        req.push('RemoteParcelRequest');
        req.push('RenderMaterials');
        req.push('RequestTextureDownload');
        req.push('ResourceCostSelected');
        req.push('RetrieveNavMeshSrc');
        req.push('SearchStatRequest');
        req.push('SearchStatTracking');
        req.push('SendPostcard');
        req.push('SendUserReport');
        req.push('SendUserReportWithScreenshot');
        req.push('ServerReleaseNotes');
        req.push('SetDisplayName');
        req.push('SimConsoleAsync');
        req.push('SimulatorFeatures');
        req.push('StartGroupProposal');
        req.push('TerrainNavMeshProperties');
        req.push('TextureStats');
        req.push('UntrustedSimulatorMessage');
        req.push('UpdateAgentInformation');
        req.push('UpdateAgentLanguage');
        req.push('UpdateAvatarAppearance');
        req.push('UpdateGestureAgentInventory');
        req.push('UpdateGestureTaskInventory');
        req.push('UpdateNotecardAgentInventory');
        req.push('UpdateNotecardTaskInventory');
        req.push('UpdateScriptAgent');
        req.push('UpdateScriptTask');
        req.push('UpdateSettingsAgentInventory');
        req.push('UpdateSettingsTaskInventory');
        req.push('UploadBakedTexture');
        req.push('UserInfo');
        req.push('ViewerAsset');
        req.push('ViewerBenefits');
        req.push('ViewerMetrics');
        req.push('ViewerStartAuction');
        req.push('ViewerStats');
        this.active = true;
        this.request(seedURL, LLSD.LLSD.formatXML(req), 'application/llsd+xml').then((resp) => {
            this.capabilities = LLSD.LLSD.parseXML(resp.body);
            this.gotSeedCap = true;
            this.onGotSeedCap.next();
            if (this.capabilities['EventQueueGet']) {
                if (this.eventQueueClient !== null) {
                    this.eventQueueClient.shutdown();
                }
                this.eventQueueClient = new EventQueueClient_1.EventQueueClient(this.agent, this, this.clientEvents);
            }
        }).catch((err) => {
            console.error('Error getting seed capability');
            console.error(err);
        });
    }
    downloadAsset(uuid, type) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (type === HTTPAssets_1.HTTPAssets.ASSET_LSL_TEXT || type === HTTPAssets_1.HTTPAssets.ASSET_NOTECARD) {
                    throw new Error('Invalid Syntax');
                }
                this.getCapability('ViewerAsset').then((capURL) => {
                    const assetURL = capURL + '/?' + type + '_id=' + uuid.toString();
                    request({
                        'uri': assetURL,
                        'rejectUnauthorized': false,
                        'method': 'GET',
                        'encoding': null
                    }, (err, _res, body) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(body);
                        }
                    });
                }).catch((err) => {
                    reject(err);
                });
            });
        });
    }
    request(capURL, data, contentType) {
        return new Promise((resolve, reject) => {
            request({
                'headers': {
                    'Content-Length': data.length,
                    'Content-Type': contentType
                },
                'uri': capURL,
                'body': data,
                'rejectUnauthorized': false,
                'method': 'POST'
            }, (err, res, body) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve({ status: res.statusCode, body: body });
                }
            });
        });
    }
    requestPut(capURL, data, contentType) {
        return new Promise((resolve, reject) => {
            request({
                'headers': {
                    'Content-Length': data.length,
                    'Content-Type': contentType
                },
                'uri': capURL,
                'body': data,
                'rejectUnauthorized': false,
                'method': 'PUT'
            }, (err, res, body) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve({ status: res.statusCode, body: body });
                }
            });
        });
    }
    requestGet(requestURL) {
        return new Promise((resolve, reject) => {
            request({
                'uri': requestURL,
                'rejectUnauthorized': false,
                'method': 'GET'
            }, (err, res, body) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve({ status: res.statusCode, body: body });
                }
            });
        });
    }
    requestDelete(requestURL) {
        return new Promise((resolve, reject) => {
            request({
                'uri': requestURL,
                'rejectUnauthorized': false,
                'method': 'DELETE'
            }, (err, res, body) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve({ status: res.statusCode, body: body });
                }
            });
        });
    }
    waitForSeedCapability() {
        return new Promise((resolve) => {
            if (this.gotSeedCap) {
                resolve();
            }
            else {
                const sub = this.onGotSeedCap.subscribe(() => {
                    sub.unsubscribe();
                    resolve();
                });
            }
        });
    }
    isCapAvailable(capability) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.waitForSeedCapability();
            return (this.capabilities[capability] !== undefined);
        });
    }
    getCapability(capability) {
        return new Promise((resolve, reject) => {
            if (!this.active) {
                reject(new Error('Requesting getCapability to an inactive Caps instance'));
                return;
            }
            this.waitForSeedCapability().then(() => {
                if (this.capabilities[capability]) {
                    resolve(this.capabilities[capability]);
                }
                else {
                    reject(new Error('Capability ' + capability + ' not available'));
                }
            });
        });
    }
    capsRequestUpload(capURL, data) {
        return new Promise((resolve, reject) => {
            this.request(capURL, data, 'application/octet-stream').then((resp) => {
                try {
                    resolve(LLSD.LLSD.parseXML(resp.body));
                }
                catch (err) {
                    if (resp.status === 201) {
                        resolve({});
                    }
                    else if (resp.status === 403) {
                        reject(new Error('Access Denied'));
                    }
                    else {
                        reject(err);
                    }
                }
            }).catch((err) => {
                console.error(err);
                reject(err);
            });
        });
    }
    waitForCapTimeout(capName) {
        return new Promise((resolve) => {
            if (!Caps.CAP_INVOCATION_DELAY_MS[capName]) {
                resolve();
            }
            else {
                if (!this.timeLastCapExecuted[capName] || this.timeLastCapExecuted[capName] < (new Date().getTime() - Caps.CAP_INVOCATION_DELAY_MS[capName])) {
                    this.timeLastCapExecuted[capName] = new Date().getTime();
                }
                else {
                    this.timeLastCapExecuted[capName] += Caps.CAP_INVOCATION_DELAY_MS[capName];
                }
                const timeToWait = this.timeLastCapExecuted[capName] - new Date().getTime();
                if (timeToWait > 0) {
                    setTimeout(() => {
                        resolve();
                    }, timeToWait);
                }
                else {
                    resolve();
                }
            }
        });
    }
    capsPerformXMLPost(capURL, data) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const xml = LLSD.LLSD.formatXML(data);
            this.request(capURL, xml, 'application/llsd+xml').then((resp) => __awaiter(this, void 0, void 0, function* () {
                let result = null;
                try {
                    result = LLSD.LLSD.parseXML(resp.body);
                    resolve(result);
                }
                catch (err) {
                    if (resp.status === 201) {
                        resolve({});
                    }
                    else if (resp.status === 403) {
                        reject(new Error('Access Denied'));
                    }
                    else if (resp.status === 404) {
                        reject(new Error('Not found'));
                    }
                    else {
                        reject(resp.body);
                    }
                }
            })).catch((err) => {
                console.error(err);
                reject(err);
            });
        }));
    }
    capsPerformXMLPut(capURL, data) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const xml = LLSD.LLSD.formatXML(data);
            this.requestPut(capURL, xml, 'application/llsd+xml').then((resp) => {
                let result = null;
                try {
                    result = LLSD.LLSD.parseXML(resp.body);
                    resolve(result);
                }
                catch (err) {
                    if (resp.status === 201) {
                        resolve({});
                    }
                    else if (resp.status === 403) {
                        reject(new Error('Access Denied'));
                    }
                    else {
                        reject(err);
                    }
                }
            }).catch((err) => {
                console.error(err);
                reject(err);
            });
        }));
    }
    capsPerformXMLGet(capURL) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            this.requestGet(capURL).then((resp) => {
                let result = null;
                try {
                    result = LLSD.LLSD.parseXML(resp.body);
                    resolve(result);
                }
                catch (err) {
                    if (resp.status === 201) {
                        resolve({});
                    }
                    else if (resp.status === 403) {
                        reject(new Error('Access Denied'));
                    }
                    else {
                        reject(err);
                    }
                }
            }).catch((err) => {
                console.error(err);
                reject(err);
            });
        }));
    }
    capsGetXML(capability) {
        return __awaiter(this, void 0, void 0, function* () {
            let capName = '';
            let queryParams = {};
            if (typeof capability === 'string') {
                capName = capability;
            }
            else {
                capName = capability[0];
                queryParams = capability[1];
            }
            yield this.waitForCapTimeout(capName);
            let capURL = yield this.getCapability(capName);
            if (Object.keys(queryParams).length > 0) {
                const parsedURL = url.parse(capURL, true);
                for (const key of Object.keys(queryParams)) {
                    parsedURL.query[key] = queryParams[key];
                }
                capURL = url.format(parsedURL);
            }
            try {
                return yield this.capsPerformXMLGet(capURL);
            }
            catch (error) {
                console.log('Error with cap ' + capName);
                console.log(error);
                throw error;
            }
        });
    }
    capsPostXML(capability, data) {
        return __awaiter(this, void 0, void 0, function* () {
            let capName = '';
            let queryParams = {};
            if (typeof capability === 'string') {
                capName = capability;
            }
            else {
                capName = capability[0];
                queryParams = capability[1];
            }
            yield this.waitForCapTimeout(capName);
            let capURL = yield this.getCapability(capName);
            if (Object.keys(queryParams).length > 0) {
                const parsedURL = url.parse(capURL, true);
                for (const key of Object.keys(queryParams)) {
                    parsedURL.query[key] = queryParams[key];
                }
                capURL = url.format(parsedURL);
            }
            try {
                return yield this.capsPerformXMLPost(capURL, data);
            }
            catch (error) {
                console.log('Error with cap ' + capName);
                console.log(error);
                throw error;
            }
        });
    }
    capsPutXML(capability, data) {
        return __awaiter(this, void 0, void 0, function* () {
            let capName = '';
            let queryParams = {};
            if (typeof capability === 'string') {
                capName = capability;
            }
            else {
                capName = capability[0];
                queryParams = capability[1];
            }
            yield this.waitForCapTimeout(capName);
            let capURL = yield this.getCapability(capName);
            if (Object.keys(queryParams).length > 0) {
                const parsedURL = url.parse(capURL, true);
                for (const key of Object.keys(queryParams)) {
                    parsedURL.query[key] = queryParams[key];
                }
                capURL = url.format(parsedURL);
            }
            try {
                return yield this.capsPerformXMLPut(capURL, data);
            }
            catch (error) {
                console.log('Error with cap ' + capName);
                console.log(error);
                throw error;
            }
        });
    }
    shutdown() {
        this.onGotSeedCap.complete();
        if (this.eventQueueClient) {
            this.eventQueueClient.shutdown();
        }
        this.active = false;
    }
}
exports.Caps = Caps;
Caps.CAP_INVOCATION_DELAY_MS = {
    'NewFileAgentInventory': 2000,
    'FetchInventory2': 200
};
//# sourceMappingURL=Caps.js.map