"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Inventory = void 0;
const UUID_1 = require("./UUID");
const InventoryFolder_1 = require("./InventoryFolder");
const LLSD = require("@caspertech/llsd");
const InventoryItem_1 = require("./InventoryItem");
const InventoryLibrary_1 = require("../enums/InventoryLibrary");
class Inventory {
    constructor(clientEvents, agent) {
        this.main = {
            skeleton: {}
        };
        this.library = {
            skeleton: {}
        };
        this.itemsByID = {};
        this.agent = agent;
        this.clientEvents = clientEvents;
    }
    getRootFolderLibrary() {
        if (this.library.root === undefined) {
            return new InventoryFolder_1.InventoryFolder(InventoryLibrary_1.InventoryLibrary.Library, this.library, this.agent);
        }
        const uuidStr = this.library.root.toString();
        if (this.library.skeleton[uuidStr]) {
            return this.library.skeleton[uuidStr];
        }
        else {
            return new InventoryFolder_1.InventoryFolder(InventoryLibrary_1.InventoryLibrary.Library, this.library, this.agent);
        }
    }
    getRootFolderMain() {
        if (this.main.root === undefined) {
            return new InventoryFolder_1.InventoryFolder(InventoryLibrary_1.InventoryLibrary.Main, this.main, this.agent);
        }
        const uuidStr = this.main.root.toString();
        if (this.main.skeleton[uuidStr]) {
            return this.main.skeleton[uuidStr];
        }
        else {
            return new InventoryFolder_1.InventoryFolder(InventoryLibrary_1.InventoryLibrary.Main, this.main, this.agent);
        }
    }
    findFolderForType(type) {
        const root = this.main.skeleton;
        for (const key of Object.keys(root)) {
            const f = root[key];
            if (f.typeDefault === type) {
                return f.folderID;
            }
        }
        return this.getRootFolderMain().folderID;
    }
    findFolder(folderID) {
        for (const id of Object.keys(this.main.skeleton)) {
            if (folderID.equals(id)) {
                return this.main.skeleton[id];
            }
            else {
                const result = this.main.skeleton[id].findFolder(folderID);
                if (result !== null) {
                    return result;
                }
            }
        }
        return null;
    }
    fetchInventoryItem(item) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = {
                'agent_id': new LLSD.UUID(this.agent.agentID),
                'items': [
                    {
                        'item_id': new LLSD.UUID(item),
                        'owner_id': new LLSD.UUID(this.agent.agentID)
                    }
                ]
            };
            const response = yield this.agent.currentRegion.caps.capsPostXML('FetchInventory2', params);
            if (response['items'].length > 0) {
                const receivedItem = response['items'][0];
                let folder = yield this.findFolder(new UUID_1.UUID(receivedItem['parent_id'].toString()));
                if (folder === null) {
                    folder = this.getRootFolderMain();
                }
                const invItem = new InventoryItem_1.InventoryItem(folder, this.agent);
                invItem.assetID = new UUID_1.UUID(receivedItem['asset_id'].toString());
                invItem.inventoryType = parseInt(receivedItem['inv_type'], 10);
                invItem.type = parseInt(receivedItem['type'], 10);
                invItem.itemID = item;
                if (receivedItem['permissions']['last_owner_id'] === undefined) {
                    // TODO: OpenSim glitch
                    receivedItem['permissions']['last_owner_id'] = receivedItem['permissions']['owner_id'];
                }
                invItem.permissions = {
                    baseMask: parseInt(receivedItem['permissions']['base_mask'], 10),
                    nextOwnerMask: parseInt(receivedItem['permissions']['next_owner_mask'], 10),
                    groupMask: parseInt(receivedItem['permissions']['group_mask'], 10),
                    lastOwner: new UUID_1.UUID(receivedItem['permissions']['last_owner_id'].toString()),
                    owner: new UUID_1.UUID(receivedItem['permissions']['owner_id'].toString()),
                    creator: new UUID_1.UUID(receivedItem['permissions']['creator_id'].toString()),
                    group: new UUID_1.UUID(receivedItem['permissions']['group_id'].toString()),
                    ownerMask: parseInt(receivedItem['permissions']['owner_mask'], 10),
                    everyoneMask: parseInt(receivedItem['permissions']['everyone_mask'], 10),
                };
                invItem.flags = parseInt(receivedItem['flags'], 10);
                invItem.description = receivedItem['desc'];
                invItem.name = receivedItem['name'];
                invItem.created = new Date(receivedItem['created_at'] * 1000);
                invItem.parentID = new UUID_1.UUID(receivedItem['parent_id'].toString());
                invItem.saleType = parseInt(receivedItem['sale_info']['sale_type'], 10);
                invItem.salePrice = parseInt(receivedItem['sale_info']['sale_price'], 10);
                if (this.main.skeleton[invItem.parentID.toString()]) {
                    yield this.main.skeleton[invItem.parentID.toString()].addItem(invItem);
                }
                return invItem;
            }
            else {
                return null;
            }
        });
    }
}
exports.Inventory = Inventory;
//# sourceMappingURL=Inventory.js.map