"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectStoreLite = void 0;
const Logger_1 = require("./Logger");
const Message_1 = require("../enums/Message");
const RequestMultipleObjects_1 = require("./messages/RequestMultipleObjects");
const UUID_1 = require("./UUID");
const Utils_1 = require("./Utils");
const NameValue_1 = require("./NameValue");
const GameObject_1 = require("./public/GameObject");
const FilterResponse_1 = require("../enums/FilterResponse");
const ObjectSelect_1 = require("./messages/ObjectSelect");
const ObjectDeselect_1 = require("./messages/ObjectDeselect");
const Quaternion_1 = require("./Quaternion");
const ExtraParams_1 = require("./public/ExtraParams");
const SelectedObjectEvent_1 = require("../events/SelectedObjectEvent");
const PrimFlags_1 = require("../enums/PrimFlags");
const PacketFlags_1 = require("../enums/PacketFlags");
const PCode_1 = require("../enums/PCode");
const BotOptionFlags_1 = require("../enums/BotOptionFlags");
const NewObjectEvent_1 = require("../events/NewObjectEvent");
const ObjectUpdatedEvent_1 = require("../events/ObjectUpdatedEvent");
const CompressedFlags_1 = require("../enums/CompressedFlags");
const Vector3_1 = require("./Vector3");
const ObjectResolvedEvent_1 = require("../events/ObjectResolvedEvent");
const Avatar_1 = require("./public/Avatar");
class ObjectStoreLite {
    constructor(circuit, agent, clientEvents, options) {
        this.objects = {};
        this.objectsByUUID = {};
        this.objectsByParent = {};
        this.requestedObjects = {};
        this.deadObjects = [];
        this.persist = false;
        this.pendingObjectProperties = {};
        this.selectedPrimsWithoutUpdate = {};
        agent.localID = 0;
        this.options = options;
        this.clientEvents = clientEvents;
        this.circuit = circuit;
        this.agent = agent;
        this.circuit.subscribeToMessages([
            Message_1.Message.ObjectUpdate,
            Message_1.Message.ObjectUpdateCached,
            Message_1.Message.ObjectUpdateCompressed,
            Message_1.Message.ImprovedTerseObjectUpdate,
            Message_1.Message.ObjectProperties,
            Message_1.Message.KillObject
        ], (packet) => __awaiter(this, void 0, void 0, function* () {
            switch (packet.message.id) {
                case Message_1.Message.ObjectProperties:
                    {
                        const objProp = packet.message;
                        for (const obj of objProp.ObjectData) {
                            const obje = this.objectsByUUID[obj.ObjectID.toString()];
                            if (obje !== undefined && this.objects[obje] !== undefined) {
                                const o = this.objects[obje];
                                this.applyObjectProperties(o, obj);
                            }
                            else {
                                this.pendingObjectProperties[obj.ObjectID.toString()] = obj;
                            }
                        }
                        break;
                    }
                case Message_1.Message.ObjectUpdate:
                    {
                        const objectUpdate = packet.message;
                        this.objectUpdate(objectUpdate);
                        break;
                    }
                case Message_1.Message.ObjectUpdateCached:
                    {
                        const objectUpdateCached = packet.message;
                        this.objectUpdateCached(objectUpdateCached);
                        break;
                    }
                case Message_1.Message.ObjectUpdateCompressed:
                    {
                        const objectUpdateCompressed = packet.message;
                        yield this.objectUpdateCompressed(objectUpdateCompressed);
                        break;
                    }
                case Message_1.Message.ImprovedTerseObjectUpdate:
                    {
                        const objectUpdateTerse = packet.message;
                        this.objectUpdateTerse(objectUpdateTerse);
                        break;
                    }
                case Message_1.Message.KillObject:
                    {
                        const killObj = packet.message;
                        this.killObject(killObj);
                        break;
                    }
            }
        }));
        this.physicsSubscription = this.clientEvents.onPhysicsDataEvent.subscribe((evt) => {
            if (this.objects[evt.localID]) {
                this.objects[evt.localID].physicsShapeType = evt.physicsShapeType;
                this.objects[evt.localID].density = evt.density;
                this.objects[evt.localID].restitution = evt.restitution;
                this.objects[evt.localID].gravityMultiplier = evt.gravityMultiplier;
                this.objects[evt.localID].friction = evt.friction;
            }
        });
        this.selectedChecker = setInterval(() => {
            if (this.circuit === undefined) {
                return;
            }
            try {
                let selectObjects = [];
                for (const key of Object.keys(this.selectedPrimsWithoutUpdate)) {
                    selectObjects.push(key);
                }
                function shuffle(a) {
                    let j, x, i;
                    for (i = a.length - 1; i > 0; i--) {
                        j = Math.floor(Math.random() * (i + 1));
                        x = a[i];
                        a[i] = a[j];
                        a[j] = x;
                    }
                    return a;
                }
                selectObjects = shuffle(selectObjects);
                if (selectObjects.length > 10) {
                    selectObjects = selectObjects.slice(0, 20);
                }
                if (selectObjects.length > 0) {
                    const selectObject = new ObjectSelect_1.ObjectSelectMessage();
                    selectObject.AgentData = {
                        AgentID: this.agent.agentID,
                        SessionID: this.circuit.sessionID
                    };
                    selectObject.ObjectData = [];
                    for (const id of selectObjects) {
                        selectObject.ObjectData.push({
                            ObjectLocalID: parseInt(id, 10)
                        });
                    }
                    this.circuit.sendMessage(selectObject, PacketFlags_1.PacketFlags.Reliable);
                }
            }
            catch (e) {
                Logger_1.Logger.Error(e);
            }
        }, 1000);
    }
    applyObjectProperties(o, obj) {
        if (this.selectedPrimsWithoutUpdate[o.ID]) {
            delete this.selectedPrimsWithoutUpdate[o.ID];
        }
        // const n = Utils.BufferToStringSimple(obj.Name); // Currently unused
        o.creatorID = obj.CreatorID;
        o.creationDate = obj.CreationDate;
        o.baseMask = obj.BaseMask;
        o.ownerMask = obj.OwnerMask;
        o.groupMask = obj.GroupMask;
        o.everyoneMask = obj.EveryoneMask;
        o.nextOwnerMask = obj.NextOwnerMask;
        o.ownershipCost = obj.OwnershipCost;
        o.saleType = obj.SaleType;
        o.salePrice = obj.SalePrice;
        o.aggregatePerms = obj.AggregatePerms;
        o.aggregatePermTextures = obj.AggregatePermTextures;
        o.aggregatePermTexturesOwner = obj.AggregatePermTexturesOwner;
        o.category = obj.Category;
        o.inventorySerial = obj.InventorySerial;
        o.itemID = obj.ItemID;
        o.folderID = obj.FolderID;
        o.fromTaskID = obj.FromTaskID;
        o.groupID = obj.GroupID;
        o.lastOwnerID = obj.LastOwnerID;
        o.name = Utils_1.Utils.BufferToStringSimple(obj.Name);
        o.description = Utils_1.Utils.BufferToStringSimple(obj.Description);
        o.touchName = Utils_1.Utils.BufferToStringSimple(obj.TouchName);
        o.sitName = Utils_1.Utils.BufferToStringSimple(obj.SitName);
        o.textureID = Utils_1.Utils.BufferToStringSimple(obj.TextureID);
        if (!o.resolvedAt) {
            o.resolvedAt = new Date().getTime() / 1000;
        }
        {
            const evt = new ObjectResolvedEvent_1.ObjectResolvedEvent();
            evt.object = o;
            this.clientEvents.onObjectResolvedEvent.next(evt);
        }
        if (o.Flags !== undefined) {
            // tslint:disable-next-line:no-bitwise
            // noinspection JSBitwiseOperatorUsage
            if (o.Flags & PrimFlags_1.PrimFlags.CreateSelected) {
                const evt = new SelectedObjectEvent_1.SelectedObjectEvent();
                evt.object = o;
                this.clientEvents.onSelectedObjectEvent.next(evt);
            }
        }
    }
    requestMissingObject(localID, attempt = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.requestedObjects[localID]) {
                return;
            }
            if (this.circuit === undefined) {
                return;
            }
            this.requestedObjects[localID] = true;
            const rmo = new RequestMultipleObjects_1.RequestMultipleObjectsMessage();
            rmo.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: this.circuit.sessionID
            };
            rmo.ObjectData = [];
            rmo.ObjectData.push({
                CacheMissType: 0,
                ID: localID
            });
            this.circuit.sendMessage(rmo, PacketFlags_1.PacketFlags.Reliable);
            const selectObject = new ObjectSelect_1.ObjectSelectMessage();
            selectObject.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: this.circuit.sessionID
            };
            selectObject.ObjectData = [
                {
                    'ObjectLocalID': localID
                }
            ];
            this.circuit.sendMessage(selectObject, PacketFlags_1.PacketFlags.Reliable);
            try {
                yield this.circuit.waitForMessage(Message_1.Message.ObjectUpdate, 10000, (message) => {
                    for (const obj of message.ObjectData) {
                        if (obj.ID === localID) {
                            return FilterResponse_1.FilterResponse.Finish;
                        }
                    }
                    return FilterResponse_1.FilterResponse.NoMatch;
                });
                delete this.requestedObjects[localID];
            }
            catch (error) {
                delete this.requestedObjects[localID];
                if (attempt < 5) {
                    yield this.requestMissingObject(localID, ++attempt);
                }
                else {
                    if (!this.circuit) {
                        return;
                    }
                    console.error('Error retrieving missing object after 5 attempts: ' + localID);
                    console.error(error);
                }
            }
            finally {
                if (this.circuit) {
                    const deselectObject = new ObjectDeselect_1.ObjectDeselectMessage();
                    deselectObject.AgentData = {
                        AgentID: this.agent.agentID,
                        SessionID: this.circuit.sessionID
                    };
                    deselectObject.ObjectData = [
                        {
                            'ObjectLocalID': localID
                        }
                    ];
                    this.circuit.sendMessage(selectObject, PacketFlags_1.PacketFlags.Reliable);
                }
            }
        });
    }
    objectUpdate(objectUpdate) {
        for (const objData of objectUpdate.ObjectData) {
            const localID = objData.ID;
            const parentID = objData.ParentID;
            let addToParentList = true;
            let newObject = false;
            if (this.objects[localID]) {
                if (this.objects[localID].ParentID !== parentID && this.objectsByParent[parentID]) {
                    const ind = this.objectsByParent[parentID].indexOf(localID);
                    if (ind !== -1) {
                        this.objectsByParent[parentID].splice(ind, 1);
                    }
                }
                else if (this.objectsByParent[parentID]) {
                    addToParentList = false;
                }
            }
            else {
                newObject = true;
                this.objects[localID] = new GameObject_1.GameObject();
                this.objects[localID].region = this.agent.currentRegion;
            }
            const obj = this.objects[localID];
            obj.deleted = false;
            obj.ID = objData.ID;
            obj.FullID = objData.FullID;
            obj.ParentID = objData.ParentID;
            obj.OwnerID = objData.OwnerID;
            obj.PCode = objData.PCode;
            this.objects[localID].NameValue = this.parseNameValues(Utils_1.Utils.BufferToStringSimple(objData.NameValue));
            this.objects[localID].IsAttachment = this.objects[localID].NameValue['AttachItemID'] !== undefined;
            if (obj.IsAttachment && obj.State !== undefined) {
                this.objects[localID].attachmentPoint = this.decodeAttachPoint(obj.State);
            }
            if (objData.PCode === PCode_1.PCode.Avatar && this.objects[localID].FullID.toString() === this.agent.agentID.toString()) {
                this.agent.localID = localID;
                if (this.options & BotOptionFlags_1.BotOptionFlags.StoreMyAttachmentsOnly) {
                    for (const objParentID of Object.keys(this.objectsByParent)) {
                        const parent = parseInt(objParentID, 10);
                        if (parent !== this.agent.localID) {
                            let foundAvatars = false;
                            for (const objID of this.objectsByParent[parent]) {
                                if (this.objects[objID]) {
                                    const o = this.objects[objID];
                                    if (o.PCode === PCode_1.PCode.Avatar) {
                                        foundAvatars = true;
                                    }
                                }
                            }
                            if (this.objects[parent]) {
                                const o = this.objects[parent];
                                if (o.PCode === PCode_1.PCode.Avatar) {
                                    foundAvatars = true;
                                }
                            }
                            if (!foundAvatars) {
                                this.deleteObject(parent);
                            }
                        }
                    }
                }
            }
            this.objectsByUUID[objData.FullID.toString()] = localID;
            if (!this.objectsByParent[parentID]) {
                this.objectsByParent[parentID] = [];
            }
            if (addToParentList) {
                this.objectsByParent[parentID].push(localID);
            }
            if (objData.PCode !== PCode_1.PCode.Avatar && this.options & BotOptionFlags_1.BotOptionFlags.StoreMyAttachmentsOnly) {
                if (this.agent.localID !== 0 && obj.ParentID !== this.agent.localID) {
                    // Drop object
                    this.deleteObject(localID);
                    return;
                }
            }
            this.notifyObjectUpdate(newObject, obj);
            if (objData.ParentID !== undefined && objData.ParentID !== 0 && !this.objects[objData.ParentID]) {
                this.requestMissingObject(objData.ParentID);
            }
        }
    }
    notifyTerseUpdate(obj) {
        if (this.objects[obj.ID]) {
            if (obj.PCode === PCode_1.PCode.Avatar) {
                if (this.agent.currentRegion.agents[obj.FullID.toString()] !== undefined) {
                    this.agent.currentRegion.agents[obj.FullID.toString()].processObjectUpdate(obj);
                }
                else {
                    console.warn('Received update for unknown avatar, but not a new object?!');
                }
            }
            const updObj = new ObjectUpdatedEvent_1.ObjectUpdatedEvent();
            updObj.localID = obj.ID;
            updObj.objectID = obj.FullID;
            updObj.object = obj;
            this.clientEvents.onObjectUpdatedTerseEvent.next(updObj);
        }
    }
    notifyObjectUpdate(newObject, obj) {
        if (obj.PCode === PCode_1.PCode.Avatar) {
            const avatarID = obj.FullID.toString();
            if (newObject) {
                if (this.agent.currentRegion.agents[avatarID] === undefined) {
                    const av = Avatar_1.Avatar.fromGameObject(obj);
                    this.agent.currentRegion.agents[avatarID] = av;
                    this.clientEvents.onAvatarEnteredRegion.next(av);
                }
                else {
                    this.agent.currentRegion.agents[avatarID].processObjectUpdate(obj);
                }
            }
            else {
                if (this.agent.currentRegion.agents[avatarID] !== undefined) {
                    this.agent.currentRegion.agents[avatarID].processObjectUpdate(obj);
                }
                else {
                    console.warn('Received update for unknown avatar, but not a new object?!');
                }
            }
        }
        if (obj.ParentID === 0 || (obj.ParentID !== undefined && this.objects[obj.ParentID] !== undefined && this.objects[obj.ParentID].PCode === PCode_1.PCode.Avatar)) {
            if (newObject) {
                if (obj.IsAttachment && obj.ParentID !== undefined) {
                    if (this.objects[obj.ParentID] !== undefined && this.objects[obj.ParentID].PCode === PCode_1.PCode.Avatar) {
                        const avatar = this.agent.currentRegion.agents[this.objects[obj.ParentID].FullID.toString()];
                        let invItemID = UUID_1.UUID.zero();
                        if (obj.NameValue['AttachItemID']) {
                            invItemID = new UUID_1.UUID(obj.NameValue['AttachItemID'].value);
                        }
                        this.agent.currentRegion.clientCommands.region.resolveObject(obj, true, false).then(() => {
                            try {
                                if (obj.itemID === undefined) {
                                    obj.itemID = UUID_1.UUID.zero();
                                }
                                obj.itemID = invItemID;
                                if (avatar !== undefined) {
                                    avatar.addAttachment(obj);
                                }
                            }
                            catch (err) {
                                console.error(err);
                            }
                        }).catch(() => {
                            console.error('Failed to resolve new avatar attachment');
                        });
                    }
                }
                const newObj = new NewObjectEvent_1.NewObjectEvent();
                newObj.localID = obj.ID;
                newObj.objectID = obj.FullID;
                newObj.object = obj;
                newObj.createSelected = obj.Flags !== undefined && (obj.Flags & PrimFlags_1.PrimFlags.CreateSelected) !== 0;
                obj.createdSelected = newObj.createSelected;
                // tslint:disable-next-line:no-bitwise
                // noinspection JSBitwiseOperatorUsage
                if (obj.Flags !== undefined && obj.Flags & PrimFlags_1.PrimFlags.CreateSelected && !this.pendingObjectProperties[obj.FullID.toString()]) {
                    this.selectedPrimsWithoutUpdate[obj.ID] = true;
                }
                this.clientEvents.onNewObjectEvent.next(newObj);
            }
            else {
                const updObj = new ObjectUpdatedEvent_1.ObjectUpdatedEvent();
                updObj.localID = obj.ID;
                updObj.objectID = obj.FullID;
                updObj.object = obj;
                this.clientEvents.onObjectUpdatedEvent.next(updObj);
            }
            if (this.pendingObjectProperties[obj.FullID.toString()]) {
                this.applyObjectProperties(obj, this.pendingObjectProperties[obj.FullID.toString()]);
                delete this.pendingObjectProperties[obj.FullID.toString()];
            }
        }
    }
    objectUpdateCached(objectUpdateCached) {
        if (this.circuit === undefined) {
            return;
        }
        const rmo = new RequestMultipleObjects_1.RequestMultipleObjectsMessage();
        rmo.AgentData = {
            AgentID: this.agent.agentID,
            SessionID: this.circuit.sessionID
        };
        rmo.ObjectData = [];
        for (const obj of objectUpdateCached.ObjectData) {
            rmo.ObjectData.push({
                CacheMissType: 0,
                ID: obj.ID
            });
        }
        this.circuit.sendMessage(rmo, 0);
    }
    objectUpdateCompressed(objectUpdateCompressed) {
        for (const obj of objectUpdateCompressed.ObjectData) {
            const buf = obj.Data;
            let pos = 0;
            const fullID = new UUID_1.UUID(buf, pos);
            pos += 16;
            const localID = buf.readUInt32LE(pos);
            pos += 4;
            const pcode = buf.readUInt8(pos++);
            let newObj = false;
            if (!this.objects[localID]) {
                newObj = true;
                this.objects[localID] = new GameObject_1.GameObject();
                this.objects[localID].region = this.agent.currentRegion;
            }
            const o = this.objects[localID];
            o.deleted = false;
            o.ID = localID;
            o.PCode = pcode;
            this.objectsByUUID[fullID.toString()] = localID;
            o.FullID = fullID;
            pos++;
            pos = pos + 42;
            const compressedflags = buf.readUInt32LE(pos);
            pos = pos + 4;
            o.OwnerID = new UUID_1.UUID(buf, pos);
            pos += 16;
            if (compressedflags & CompressedFlags_1.CompressedFlags.HasAngularVelocity) {
                pos = pos + 12;
            }
            let newParentID = 0;
            if (compressedflags & CompressedFlags_1.CompressedFlags.HasParent) {
                newParentID = buf.readUInt32LE(pos);
                pos += 4;
            }
            o.ParentID = newParentID;
            let add = true;
            if (!newObj && o.ParentID !== undefined) {
                if (newParentID !== o.ParentID) {
                    const index = this.objectsByParent[o.ParentID].indexOf(localID);
                    if (index !== -1) {
                        this.objectsByParent[o.ParentID].splice(index, 1);
                    }
                }
                else if (this.objectsByParent[o.ParentID]) {
                    add = false;
                }
            }
            if (add) {
                if (!this.objectsByParent[newParentID]) {
                    this.objectsByParent[newParentID] = [];
                }
                this.objectsByParent[newParentID].push(localID);
            }
            if (pcode !== PCode_1.PCode.Avatar && newObj && this.options & BotOptionFlags_1.BotOptionFlags.StoreMyAttachmentsOnly) {
                if (this.agent.localID !== 0 && o.ParentID !== this.agent.localID) {
                    // Drop object
                    this.deleteObject(localID);
                    return;
                }
            }
            if (o.ParentID !== undefined && o.ParentID !== 0 && !this.objects[o.ParentID]) {
                this.requestMissingObject(o.ParentID);
            }
            if (compressedflags & CompressedFlags_1.CompressedFlags.Tree) {
                pos++;
            }
            else if (compressedflags & CompressedFlags_1.CompressedFlags.ScratchPad) {
                const scratchPadSize = buf.readUInt8(pos++);
                // Ignore this data
                pos = pos + scratchPadSize;
            }
            if (compressedflags & CompressedFlags_1.CompressedFlags.HasText) {
                // Read null terminated string
                const result = Utils_1.Utils.BufferToString(buf, pos);
                pos += result.readLength;
                pos = pos + 4;
            }
            if (compressedflags & CompressedFlags_1.CompressedFlags.MediaURL) {
                const result = Utils_1.Utils.BufferToString(buf, pos);
                pos += result.readLength;
            }
            if (compressedflags & CompressedFlags_1.CompressedFlags.HasParticles) {
                pos += 86;
            }
            // Extra params
            const extraParamsLength = ExtraParams_1.ExtraParams.getLengthOfParams(buf, pos);
            o.extraParams = ExtraParams_1.ExtraParams.from(buf.slice(pos, pos + extraParamsLength));
            pos = pos + extraParamsLength;
            if (compressedflags & CompressedFlags_1.CompressedFlags.HasSound) {
                pos = pos + 25;
            }
            if (compressedflags & CompressedFlags_1.CompressedFlags.HasNameValues) {
                const result = Utils_1.Utils.BufferToString(buf, pos);
                o.NameValue = this.parseNameValues(result.result);
                pos += result.readLength;
            }
            pos++;
            pos = pos + 22;
            const textureEntryLength = buf.readUInt32LE(pos);
            pos = pos + 4;
            pos = pos + textureEntryLength;
            if (compressedflags & CompressedFlags_1.CompressedFlags.TextureAnimation) {
                pos = pos + 4;
            }
            o.IsAttachment = (compressedflags & CompressedFlags_1.CompressedFlags.HasNameValues) !== 0 && o.ParentID !== 0;
            if (o.IsAttachment && o.State !== undefined) {
                o.attachmentPoint = this.decodeAttachPoint(o.State);
            }
            this.notifyObjectUpdate(newObj, o);
        }
    }
    decodeAttachPoint(state) {
        const mask = 0xf << 4 >>> 0;
        return (((state & mask) >>> 4) | ((state & ~mask) << 4)) >>> 0;
    }
    objectUpdateTerse(_objectUpdateTerse) {
    }
    killObject(killObj) {
        for (const obj of killObj.ObjectData) {
            const objectID = obj.ID;
            if (this.objects[objectID]) {
                this.deleteObject(objectID);
            }
        }
    }
    setPersist(persist) {
        this.persist = persist;
        if (!this.persist) {
            for (const d of this.deadObjects) {
                this.deleteObject(d);
            }
            this.deadObjects = [];
        }
    }
    deleteObject(objectID) {
        var _a;
        if (this.objects[objectID]) {
            const objectUUID = this.objects[objectID].FullID;
            const obj = this.objects[objectID];
            obj.deleted = true;
            if (this.persist) {
                this.deadObjects.push(objectID);
                return;
            }
            if (obj.IsAttachment && obj.ParentID !== undefined) {
                if (this.objects[obj.ParentID] !== undefined && this.objects[obj.ParentID].PCode === PCode_1.PCode.Avatar) {
                    (_a = this.agent.currentRegion.agents[this.objects[obj.ParentID].FullID.toString()]) === null || _a === void 0 ? void 0 : _a.removeAttachment(obj);
                }
            }
            if (this.agent.currentRegion.agents[objectUUID.toString()] !== undefined) {
                this.agent.currentRegion.agents[objectUUID.toString()].isVisible = false;
            }
            // First, kill all children (not the people kind)
            if (this.objectsByParent[objectID]) {
                for (const childObjID of this.objectsByParent[objectID]) {
                    this.deleteObject(childObjID);
                }
            }
            delete this.objectsByParent[objectID];
            // Now delete this object
            const uuid = obj.FullID.toString();
            if (this.objectsByUUID[uuid]) {
                delete this.objectsByUUID[uuid];
            }
            if (obj.ParentID !== undefined) {
                const parentID = obj.ParentID;
                if (this.objectsByParent[parentID]) {
                    const ind = this.objectsByParent[parentID].indexOf(objectID);
                    if (ind !== -1) {
                        this.objectsByParent[parentID].splice(ind, 1);
                    }
                }
            }
            if (this.rtree && obj.rtreeEntry !== undefined) {
                this.rtree.remove(obj.rtreeEntry);
            }
            delete this.objects[objectID];
        }
    }
    getObjectsByParent(parentID) {
        const list = this.objectsByParent[parentID];
        if (list === undefined) {
            return [];
        }
        const result = [];
        for (const localID of list) {
            if (this.objects[localID]) {
                result.push(this.objects[localID]);
            }
        }
        result.sort((a, b) => {
            return a.ID - b.ID;
        });
        return result;
    }
    parseNameValues(str) {
        const nv = {};
        const lines = str.split('\n');
        for (const line of lines) {
            if (line.length > 0) {
                let kv = line.split(/[\t ]/);
                if (kv.length > 5) {
                    for (let x = 5; x < kv.length; x++) {
                        kv[4] += ' ' + kv[x];
                    }
                    kv = kv.slice(0, 5);
                }
                if (kv.length === 5) {
                    const namevalue = new NameValue_1.NameValue();
                    namevalue.type = kv[1];
                    namevalue.class = kv[2];
                    namevalue.sendTo = kv[3];
                    namevalue.value = kv[4];
                    nv[kv[0]] = namevalue;
                }
            }
        }
        return nv;
    }
    shutdown() {
        if (this.selectedChecker !== undefined) {
            clearInterval(this.selectedChecker);
            delete this.selectedChecker;
        }
        this.physicsSubscription.unsubscribe();
        this.objects = {};
        if (this.rtree) {
            this.rtree.clear();
        }
        this.objectsByUUID = {};
        this.objectsByParent = {};
        delete this.circuit;
    }
    findParent(go) {
        if (go.ParentID !== undefined && go.ParentID !== 0 && this.objects[go.ParentID]) {
            return this.findParent(this.objects[go.ParentID]);
        }
        else {
            if (go.ParentID !== undefined && go.ParentID !== 0 && !this.objects[go.ParentID]) {
                this.requestMissingObject(go.ParentID).catch((e) => {
                    Logger_1.Logger.Error(e);
                });
            }
            return go;
        }
    }
    populateChildren(obj, _resolve = false) {
        if (obj !== undefined) {
            obj.children = [];
            obj.totalChildren = 0;
            for (const child of this.getObjectsByParent(obj.ID)) {
                if (child.PCode !== PCode_1.PCode.Avatar) {
                    obj.totalChildren++;
                    this.populateChildren(child);
                    if (child.totalChildren !== undefined) {
                        obj.totalChildren += child.totalChildren;
                    }
                    obj.children.push(child);
                }
            }
        }
    }
    getAllObjects() {
        return __awaiter(this, void 0, void 0, function* () {
            const results = [];
            const found = {};
            for (const k of Object.keys(this.objects)) {
                const go = this.objects[parseInt(k, 10)];
                if (go.PCode !== PCode_1.PCode.Avatar && (go.IsAttachment === undefined || !go.IsAttachment)) {
                    try {
                        const parent = this.findParent(go);
                        if (parent.ParentID === 0) {
                            const uuid = parent.FullID.toString();
                            if (found[uuid] === undefined) {
                                found[uuid] = parent;
                                results.push(parent);
                            }
                        }
                    }
                    catch (error) {
                        console.log('Failed to find parent for ' + go.FullID.toString());
                        console.error(error);
                        // Unable to find parent, full object probably not fully loaded yet
                    }
                }
            }
            // Now populate children of each found object
            for (const obj of results) {
                this.populateChildren(obj);
            }
            return results;
        });
    }
    getNumberOfObjects() {
        return Object.keys(this.objects).length;
    }
    getObjectsInArea(minX, maxX, minY, maxY, minZ, maxZ) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.rtree) {
                throw new Error('GetObjectsInArea not available with the Lite object store');
            }
            const result = this.rtree.search({
                minX: minX,
                maxX: maxX,
                minY: minY,
                maxY: maxY,
                minZ: minZ,
                maxZ: maxZ
            });
            const found = {};
            const objs = [];
            for (const obj of result) {
                const o = obj;
                const go = o.gameObject;
                if (go.PCode !== PCode_1.PCode.Avatar && (go.IsAttachment === undefined || !go.IsAttachment)) {
                    try {
                        const parent = this.findParent(go);
                        if (parent.PCode !== PCode_1.PCode.Avatar && (parent.IsAttachment === undefined || !parent.IsAttachment) && parent.ParentID === 0) {
                            const uuid = parent.FullID.toString();
                            if (found[uuid] === undefined) {
                                found[uuid] = parent;
                                objs.push(parent);
                            }
                        }
                    }
                    catch (error) {
                        console.log('Failed to find parent for ' + go.FullID.toString());
                        console.error(error);
                        // Unable to find parent, full object probably not fully loaded yet
                    }
                }
            }
            // Now populate children of each found object
            for (const obj of objs) {
                this.populateChildren(obj);
            }
            return objs;
        });
    }
    getObjectByUUID(fullID) {
        if (fullID instanceof UUID_1.UUID) {
            fullID = fullID.toString();
        }
        if (!this.objectsByUUID[fullID]) {
            throw new Error('No object found with that UUID');
        }
        const localID = this.objectsByUUID[fullID];
        return this.objects[localID];
    }
    getObjectByLocalID(localID) {
        if (!this.objects[localID]) {
            throw new Error('No object found with that UUID');
        }
        return this.objects[localID];
    }
    insertIntoRtree(obj) {
        if (!this.rtree) {
            return;
        }
        if (obj.rtreeEntry !== undefined) {
            this.rtree.remove(obj.rtreeEntry);
        }
        if (!obj.Scale || !obj.Position || !obj.Rotation) {
            return;
        }
        const normalizedScale = new Vector3_1.Vector3(obj.Scale).multiplyByTSMQuat(new Quaternion_1.Quaternion(obj.Rotation));
        const bounds = {
            minX: obj.Position.x - (normalizedScale.x / 2),
            maxX: obj.Position.x + (normalizedScale.x / 2),
            minY: obj.Position.y - (normalizedScale.y / 2),
            maxY: obj.Position.y + (normalizedScale.y / 2),
            minZ: obj.Position.z - (normalizedScale.z / 2),
            maxZ: obj.Position.z + (normalizedScale.z / 2),
            gameObject: obj
        };
        obj.rtreeEntry = bounds;
        this.rtree.insert(bounds);
    }
}
exports.ObjectStoreLite = ObjectStoreLite;
//# sourceMappingURL=ObjectStoreLite.js.map