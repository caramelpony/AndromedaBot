"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Circuit = void 0;
const UUID_1 = require("./UUID");
const dgram = require("dgram");
const Packet_1 = require("./Packet");
const PacketAck_1 = require("./messages/PacketAck");
const Message_1 = require("../enums/Message");
const CompletePingCheck_1 = require("./messages/CompletePingCheck");
const operators_1 = require("rxjs/operators");
const FilterResponse_1 = require("../enums/FilterResponse");
const rxjs_1 = require("rxjs");
const TimeoutError_1 = require("./TimeoutError");
const RequestXfer_1 = require("./messages/RequestXfer");
const SendXferPacket_1 = require("./messages/SendXferPacket");
const ConfirmXferPacket_1 = require("./messages/ConfirmXferPacket");
const PacketFlags_1 = require("../enums/PacketFlags");
const Utils_1 = require("./Utils");
class Circuit {
    constructor() {
        this.client = null;
        this.sequenceNumber = 0;
        this.awaitingAck = {};
        this.receivedPackets = {};
        this.active = false;
        this.onPacketReceived = new rxjs_1.Subject();
        this.onAckReceived = new rxjs_1.Subject();
    }
    subscribeToMessages(ids, callback) {
        const lookupObject = {};
        for (const id of ids) {
            lookupObject[id] = true;
        }
        return this.onPacketReceived.pipe((0, operators_1.filter)((packet) => {
            return lookupObject[packet.message.id];
        })).subscribe(callback);
    }
    sendMessage(message, flags) {
        if (!this.active) {
            throw new Error('Attempting to send a message on a closed circuit');
        }
        const packet = new Packet_1.Packet();
        packet.message = message;
        packet.sequenceNumber = this.sequenceNumber++;
        packet.packetFlags = flags;
        this.sendPacket(packet);
        return packet.sequenceNumber;
    }
    sendXferPacket(xferID, packetID, data, pos) {
        const sendXfer = new SendXferPacket_1.SendXferPacketMessage();
        let final = false;
        sendXfer.XferID = {
            ID: xferID,
            Packet: packetID
        };
        const packetLength = Math.min(data.length - pos.position, 1000);
        if (packetLength < 1000) {
            sendXfer.XferID.Packet = (sendXfer.XferID.Packet | 0x80000000) >>> 0;
            final = true;
        }
        if (packetID === 0) {
            const packet = Buffer.allocUnsafe(packetLength + 4);
            packet.writeUInt32LE(data.length, 0);
            data.copy(packet, 4, 0, packetLength);
            sendXfer.DataPacket = {
                Data: packet
            };
            pos.position += packetLength;
        }
        else {
            const packet = data.slice(pos.position, pos.position + packetLength);
            sendXfer.DataPacket = {
                Data: packet
            };
            pos.position += packetLength;
        }
        console.log('Sent packet ' + packetID + ', ' + packetLength + ' bytes');
        this.sendMessage(sendXfer, PacketFlags_1.PacketFlags.Reliable);
        if (final) {
            pos.position = -1;
        }
    }
    XferFileUp(xferID, data) {
        return new Promise((resolve, reject) => {
            let packetID = 0;
            const pos = {
                position: 0
            };
            const subs = this.subscribeToMessages([
                Message_1.Message.AbortXfer,
                Message_1.Message.ConfirmXferPacket
            ], (packet) => {
                switch (packet.message.id) {
                    case Message_1.Message.ConfirmXferPacket:
                        {
                            const msg = packet.message;
                            if (msg.XferID.ID.equals(xferID)) {
                                if (pos.position > -1) {
                                    console.log('Packet confirmed, sending next. Position: ' + pos.position);
                                    packetID++;
                                    this.sendXferPacket(xferID, packetID, data, pos);
                                }
                            }
                            break;
                        }
                    case Message_1.Message.AbortXfer:
                        {
                            const msg = packet.message;
                            if (msg.XferID.ID.equals(xferID)) {
                                console.log('Transfer aborted');
                                subs.unsubscribe();
                                reject(new Error('Transfer aborted'));
                            }
                        }
                }
            });
            this.sendXferPacket(xferID, packetID, data, pos);
            if (pos.position === -1) {
                subs.unsubscribe();
                resolve();
            }
        });
    }
    XferFileDown(fileName, deleteOnCompletion, useBigPackets, vFileID, vFileType, fromCache) {
        return new Promise((resolve, reject) => {
            let subscription = null;
            let timeout = null;
            const receivedChunks = {};
            const resetTimeout = function () {
                if (timeout !== null) {
                    clearTimeout(timeout);
                }
                timeout = setTimeout(() => {
                    if (subscription !== null) {
                        subscription.unsubscribe();
                    }
                    reject(new Error('Xfer Timeout'));
                }, 10000);
            };
            resetTimeout();
            const xferRequest = new RequestXfer_1.RequestXferMessage();
            const transferID = UUID_1.UUID.random().getLong();
            xferRequest.XferID = {
                ID: transferID,
                Filename: Utils_1.Utils.StringToBuffer(fileName),
                FilePath: (fromCache) ? 4 : 0,
                DeleteOnCompletion: deleteOnCompletion,
                UseBigPackets: useBigPackets,
                VFileID: vFileID,
                VFileType: vFileType
            };
            this.sendMessage(xferRequest, PacketFlags_1.PacketFlags.Reliable);
            let finished = false;
            let finishID = 0;
            let firstPacket = true;
            let dataSize = 0;
            subscription = this.subscribeToMessages([
                Message_1.Message.SendXferPacket,
                Message_1.Message.AbortXfer
            ], (packet) => {
                switch (packet.message.id) {
                    case Message_1.Message.AbortXfer:
                        {
                            const message = packet.message;
                            if (message.XferID.ID.compare(transferID) === 0) {
                                if (timeout !== null) {
                                    clearTimeout(timeout);
                                }
                                if (subscription !== null) {
                                    subscription.unsubscribe();
                                }
                                reject(new Error('Xfer Aborted'));
                            }
                            break;
                        }
                    case Message_1.Message.SendXferPacket:
                        {
                            const message = packet.message;
                            if (message.XferID.ID.compare(transferID) === 0) {
                                resetTimeout();
                                const packetNum = message.XferID.Packet & 0x7FFFFFFF;
                                const finishedNow = message.XferID.Packet & 0x80000000;
                                if (firstPacket) {
                                    dataSize = message.DataPacket.Data.readUInt32LE(0);
                                    receivedChunks[packetNum] = message.DataPacket.Data.slice(4);
                                    firstPacket = false;
                                }
                                else {
                                    receivedChunks[packetNum] = message.DataPacket.Data;
                                }
                                const confirm = new ConfirmXferPacket_1.ConfirmXferPacketMessage();
                                confirm.XferID = {
                                    ID: transferID,
                                    Packet: packetNum
                                };
                                this.sendMessage(confirm, PacketFlags_1.PacketFlags.Reliable);
                                if (finishedNow) {
                                    finished = true;
                                    finishID = packetNum;
                                }
                                if (finished) {
                                    // Check if we have all the pieces
                                    for (let x = 0; x <= finishID; x++) {
                                        if (!receivedChunks[x]) {
                                            return;
                                        }
                                    }
                                    const conc = [];
                                    for (let x = 0; x <= finishID; x++) {
                                        conc.push(receivedChunks[x]);
                                    }
                                    if (timeout !== null) {
                                        clearTimeout(timeout);
                                    }
                                    if (subscription !== null) {
                                        subscription.unsubscribe();
                                    }
                                    const buf = Buffer.concat(conc);
                                    if (buf.length !== dataSize) {
                                        console.warn('Warning: Received data size does not match expected');
                                    }
                                    resolve(buf);
                                }
                            }
                            break;
                        }
                }
            });
        });
    }
    resend(sequenceNumber) {
        if (!this.active) {
            console.log('Resend triggered, but circuit is not active!');
            return;
        }
        if (this.awaitingAck[sequenceNumber]) {
            const toResend = this.awaitingAck[sequenceNumber].packet;
            toResend.packetFlags = toResend.packetFlags | PacketFlags_1.PacketFlags.Resent;
            this.sendPacket(toResend);
        }
    }
    waitForAck(ack, timeout) {
        return new Promise((resolve, reject) => {
            const handleObj = {
                timeout: null,
                subscription: null
            };
            handleObj.timeout = setTimeout(() => {
                if (handleObj.subscription !== null) {
                    handleObj.subscription.unsubscribe();
                    reject(new Error('Timeout'));
                }
            }, timeout);
            handleObj.subscription = this.onAckReceived.subscribe((sequenceNumber) => {
                if (sequenceNumber === ack) {
                    if (handleObj.timeout !== null) {
                        clearTimeout(handleObj.timeout);
                        handleObj.timeout = null;
                    }
                    if (handleObj.subscription !== null) {
                        handleObj.subscription.unsubscribe();
                        handleObj.subscription = null;
                    }
                    resolve();
                }
            });
        });
    }
    init() {
        if (this.client !== null) {
            this.client.close();
        }
        this.client = dgram.createSocket('udp4');
        this.client.on('listening', () => {
        });
        this.client.on('message', (message, remote) => {
            if (remote.address === this.ipAddress) {
                this.receivedPacket(message);
            }
        });
        this.client.on('error', () => {
        });
        this.active = true;
    }
    shutdown() {
        for (const sequenceNumber of Object.keys(this.awaitingAck)) {
            clearTimeout(this.awaitingAck[parseInt(sequenceNumber, 10)].timeout);
            delete this.awaitingAck[parseInt(sequenceNumber, 10)];
        }
        for (const sequenceNumber of Object.keys(this.receivedPackets)) {
            const seq = parseInt(sequenceNumber, 10);
            clearTimeout(this.receivedPackets[seq]);
            delete this.receivedPackets[seq];
        }
        if (this.client !== null) {
            this.client.close();
            this.client = null;
            this.onPacketReceived.complete();
            this.onAckReceived.complete();
        }
        this.active = false;
    }
    waitForMessage(id, timeout, messageFilter) {
        return new Promise((resolve, reject) => {
            const handleObj = {
                timeout: null,
                subscription: null
            };
            const timeoutFunc = () => {
                if (handleObj.subscription !== null) {
                    handleObj.subscription.unsubscribe();
                    const err = new TimeoutError_1.TimeoutError('Timeout waiting for message of type ' + Message_1.Message[id]);
                    err.timeout = true;
                    err.waitingForMessage = id;
                    reject(err);
                }
            };
            handleObj.timeout = setTimeout(timeoutFunc, timeout);
            handleObj.subscription = this.subscribeToMessages([id], (packet) => {
                let finish = false;
                if (packet.message.id === id) {
                    if (messageFilter === undefined) {
                        finish = true;
                    }
                    else {
                        const filterResult = messageFilter(packet.message);
                        if (filterResult === FilterResponse_1.FilterResponse.Finish) {
                            finish = true;
                        }
                        else if (filterResult === FilterResponse_1.FilterResponse.Match) {
                            // Extend
                            if (handleObj.timeout !== null) {
                                clearTimeout(handleObj.timeout);
                            }
                            handleObj.timeout = setTimeout(timeoutFunc, timeout);
                        }
                    }
                }
                if (finish) {
                    if (handleObj.timeout !== null) {
                        clearTimeout(handleObj.timeout);
                        handleObj.timeout = null;
                    }
                    if (handleObj.subscription !== null) {
                        handleObj.subscription.unsubscribe();
                        handleObj.subscription = null;
                    }
                    resolve(packet.message);
                }
            });
        });
    }
    sendPacket(packet) {
        if (packet.packetFlags & PacketFlags_1.PacketFlags.Reliable) {
            this.awaitingAck[packet.sequenceNumber] =
                {
                    packet: packet,
                    timeout: setTimeout(this.resend.bind(this, packet.sequenceNumber), 1000),
                    sent: new Date().getTime()
                };
        }
        let dataToSend = Buffer.allocUnsafe(packet.getSize());
        dataToSend = packet.writeToBuffer(dataToSend, 0);
        if (this.client !== null) {
            this.client.send(dataToSend, 0, dataToSend.length, this.port, this.ipAddress, (_err, _bytes) => {
            });
        }
        else {
            console.error('Attempted to send packet but UDP client is null');
        }
    }
    ackReceived(sequenceNumber) {
        if (this.awaitingAck[sequenceNumber]) {
            clearTimeout(this.awaitingAck[sequenceNumber].timeout);
            delete this.awaitingAck[sequenceNumber];
        }
        this.onAckReceived.next(sequenceNumber);
    }
    sendAck(sequenceNumber) {
        const msg = new PacketAck_1.PacketAckMessage();
        msg.Packets = [
            {
                ID: sequenceNumber
            }
        ];
        this.sendMessage(msg, 0);
    }
    getOldestUnacked() {
        let result = 0;
        let oldest = -1;
        const keys = Object.keys(this.awaitingAck);
        for (const seqID of keys) {
            const nSeq = parseInt(seqID, 10);
            if (oldest === -1 || this.awaitingAck[nSeq].sent < oldest) {
                result = nSeq;
                oldest = this.awaitingAck[nSeq].sent;
            }
        }
        return result;
    }
    expireReceivedPacket(sequenceNumber) {
        // Enough time has elapsed that we can forget about this packet
        if (this.receivedPackets[sequenceNumber]) {
            delete this.receivedPackets[sequenceNumber];
        }
    }
    receivedPacket(bytes) {
        const packet = new Packet_1.Packet();
        try {
            packet.readFromBuffer(bytes, 0, this.ackReceived.bind(this), this.sendAck.bind(this));
        }
        catch (erro) {
            console.error(erro);
            return;
        }
        if (this.receivedPackets[packet.sequenceNumber]) {
            clearTimeout(this.receivedPackets[packet.sequenceNumber]);
            this.receivedPackets[packet.sequenceNumber] = setTimeout(this.expireReceivedPacket.bind(this, packet.sequenceNumber), 10000);
            this.sendAck(packet.sequenceNumber);
            return;
        }
        this.receivedPackets[packet.sequenceNumber] = setTimeout(this.expireReceivedPacket.bind(this, packet.sequenceNumber), 10000);
        // console.log('<--- ' + packet.message.name);
        if (packet.message.id === Message_1.Message.PacketAck) {
            const msg = packet.message;
            for (const obj of msg.Packets) {
                this.ackReceived(obj.ID);
            }
        }
        else if (packet.message.id === Message_1.Message.StartPingCheck) {
            const msg = packet.message;
            const reply = new CompletePingCheck_1.CompletePingCheckMessage();
            reply.PingID = {
                PingID: msg.PingID.PingID
            };
            this.sendMessage(reply, 0);
        }
        this.onPacketReceived.next(packet);
    }
}
exports.Circuit = Circuit;
//# sourceMappingURL=Circuit.js.map