"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InventoryFolder = void 0;
const LLSD = require("@caspertech/llsd");
const fsSync = require("fs");
const fs = require("fs/promises");
const path = require("path");
const FilterResponse_1 = require("../enums/FilterResponse");
const FolderType_1 = require("../enums/FolderType");
const InventoryItemFlags_1 = require("../enums/InventoryItemFlags");
const InventoryLibrary_1 = require("../enums/InventoryLibrary");
const InventorySortOrder_1 = require("../enums/InventorySortOrder");
const InventoryType_1 = require("../enums/InventoryType");
const Message_1 = require("../enums/Message");
const PacketFlags_1 = require("../enums/PacketFlags");
const PermissionMask_1 = require("../enums/PermissionMask");
const WearableType_1 = require("../enums/WearableType");
const InventoryItem_1 = require("./InventoryItem");
const LLWearable_1 = require("./LLWearable");
const Logger_1 = require("./Logger");
const AssetUploadRequest_1 = require("./messages/AssetUploadRequest");
const CreateInventoryFolder_1 = require("./messages/CreateInventoryFolder");
const CreateInventoryItem_1 = require("./messages/CreateInventoryItem");
const LLMesh_1 = require("./public/LLMesh");
const Utils_1 = require("./Utils");
const UUID_1 = require("./UUID");
class InventoryFolder {
    constructor(lib, invBase, agent) {
        this.items = [];
        this.folders = [];
        this.callbackID = 1;
        this.agent = agent;
        this.library = lib;
        this.inventoryBase = invBase;
        const cacheLocation = path.resolve(__dirname + '/cache');
        if (!fsSync.existsSync(cacheLocation)) {
            fsSync.mkdirSync(cacheLocation, 0o777);
        }
        this.cacheDir = path.resolve(cacheLocation + '/' + this.agent.agentID.toString());
        if (!fsSync.existsSync(this.cacheDir)) {
            fsSync.mkdirSync(this.cacheDir, 0o777);
        }
    }
    getChildFolders() {
        const children = [];
        const ofi = this.folderID.toString();
        for (const uuid of Object.keys(this.inventoryBase.skeleton)) {
            const folder = this.inventoryBase.skeleton[uuid];
            if (folder.parentID.toString() === ofi) {
                children.push(folder);
            }
        }
        return children;
    }
    getChildFoldersRecursive() {
        const children = [];
        const toBrowse = [this.folderID];
        while (toBrowse.length > 0) {
            const uuid = toBrowse.pop();
            if (!uuid) {
                break;
            }
            const folder = this.inventoryBase.skeleton[uuid.toString()];
            if (folder) {
                for (const child of folder.getChildFolders()) {
                    children.push(child);
                    toBrowse.push(child.folderID);
                }
            }
        }
        return children;
    }
    createFolder(name, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = new CreateInventoryFolder_1.CreateInventoryFolderMessage();
            msg.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: this.agent.currentRegion.circuit.sessionID
            };
            msg.FolderData = {
                FolderID: UUID_1.UUID.random(),
                ParentID: this.folderID,
                Type: type,
                Name: Utils_1.Utils.StringToBuffer(name),
            };
            const ack = this.agent.currentRegion.circuit.sendMessage(msg, PacketFlags_1.PacketFlags.Reliable);
            yield this.agent.currentRegion.circuit.waitForAck(ack, 10000);
            const requestFolder = {
                folder_id: new LLSD.UUID(this.folderID),
                owner_id: new LLSD.UUID(this.agent.agentID),
                fetch_folders: true,
                fetch_items: false,
                sort_order: InventorySortOrder_1.InventorySortOrder.ByName
            };
            const requestedFolders = {
                'folders': [
                    requestFolder
                ]
            };
            let cmd = 'FetchInventoryDescendents2';
            if (this.library === InventoryLibrary_1.InventoryLibrary.Library) {
                cmd = 'FetchLibDescendents2';
            }
            const folderContents = yield this.agent.currentRegion.caps.capsPostXML(cmd, requestedFolders);
            if (folderContents['folders'] && folderContents['folders'][0] && folderContents['folders'][0]['categories'] && folderContents['folders'][0]['categories'].length > 0) {
                for (const folder of folderContents['folders'][0]['categories']) {
                    let folderID = folder['category_id'];
                    if (folderID === undefined) {
                        folderID = folder['folder_id'];
                    }
                    if (folderID === undefined) {
                        continue;
                    }
                    const foundFolderID = new UUID_1.UUID(folderID.toString());
                    if (foundFolderID.equals(msg.FolderData.FolderID)) {
                        const newFolder = new InventoryFolder(this.library, this.agent.inventory.main, this.agent);
                        newFolder.typeDefault = parseInt(folder['type_default'], 10);
                        newFolder.version = parseInt(folder['version'], 10);
                        newFolder.name = String(folder['name']);
                        newFolder.folderID = new UUID_1.UUID(folderID);
                        newFolder.parentID = new UUID_1.UUID(folder['parent_id']);
                        this.folders.push(newFolder);
                        return newFolder;
                    }
                }
            }
            throw new Error('Failed to create inventory folder');
        });
    }
    delete(saveCache = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const { caps } = this.agent.currentRegion;
            const invCap = yield caps.getCapability('InventoryAPIv3');
            yield this.agent.currentRegion.caps.requestDelete(`${invCap}/category/${this.folderID}`);
            const folders = this.getChildFoldersRecursive();
            for (const folder of folders) {
                delete this.inventoryBase.skeleton[folder.folderID.toString()];
            }
            if (saveCache) {
                for (const folder of folders) {
                    const fileName = path.join(this.cacheDir + '/' + folder.folderID.toString());
                    try {
                        const stat = yield fs.stat(fileName);
                        if (stat.isFile()) {
                            yield fs.unlink(fileName);
                        }
                    }
                    catch (error) {
                    }
                }
            }
        });
    }
    saveCache() {
        return __awaiter(this, void 0, void 0, function* () {
            const json = {
                version: this.version,
                items: this.items
            };
            const fileName = path.join(this.cacheDir + '/' + this.folderID.toString());
            yield fs.writeFile(fileName, JSON.stringify(json));
        });
    }
    loadCache() {
        return __awaiter(this, void 0, void 0, function* () {
            const fileName = path.join(this.cacheDir + '/' + this.folderID.toString());
            try {
                const data = yield fs.readFile(fileName);
                const json = JSON.parse(data.toString('utf8'));
                if (json['version'] >= this.version) {
                    this.items = [];
                    for (const item of json['items']) {
                        item.created = new Date(item.created.mUUID);
                        item.assetID = new UUID_1.UUID(item.assetID.mUUID);
                        item.parentID = new UUID_1.UUID(item.parentID.mUUID);
                        item.itemID = new UUID_1.UUID(item.itemID.mUUID);
                        item.permissions.lastOwner = new UUID_1.UUID(item.permissions.lastOwner.mUUID);
                        item.permissions.owner = new UUID_1.UUID(item.permissions.owner.mUUID);
                        item.permissions.creator = new UUID_1.UUID(item.permissions.creator.mUUID);
                        item.permissions.group = new UUID_1.UUID(item.permissions.group.mUUID);
                        yield this.addItem(item, false);
                    }
                }
                else {
                    throw new Error('Old version');
                }
            }
            catch (error) {
                throw new Error('Cache miss');
            }
        });
    }
    removeItem(itemID, save = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.agent.inventory.itemsByID[itemID.toString()]) {
                delete this.agent.inventory.itemsByID[itemID.toString()];
                this.items = this.items.filter((item) => {
                    return !item.itemID.equals(itemID);
                });
            }
            if (save) {
                return this.saveCache();
            }
        });
    }
    addItem(item, save = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.agent.inventory.itemsByID[item.itemID.toString()]) {
                yield this.removeItem(item.itemID, false);
            }
            this.items.push(item);
            this.agent.inventory.itemsByID[item.itemID.toString()] = item;
            if (save) {
                return this.saveCache();
            }
        });
    }
    populateInternal() {
        return new Promise((resolve) => {
            const requestFolder = {
                folder_id: new LLSD.UUID(this.folderID),
                owner_id: new LLSD.UUID(this.agent.agentID),
                fetch_folders: true,
                fetch_items: true,
                sort_order: InventorySortOrder_1.InventorySortOrder.ByName
            };
            const requestedFolders = {
                'folders': [
                    requestFolder
                ]
            };
            let cmd = 'FetchInventoryDescendents2';
            if (this.library === InventoryLibrary_1.InventoryLibrary.Library) {
                cmd = 'FetchLibDescendents2';
            }
            this.agent.currentRegion.caps.capsPostXML(cmd, requestedFolders).then((folderContents) => {
                for (const folder of folderContents['folders'][0]['categories']) {
                    let folderIDStr = folder['category_id'];
                    if (folderIDStr === undefined) {
                        folderIDStr = folder['folder_id'];
                    }
                    const folderID = new UUID_1.UUID(folderIDStr);
                    let found = false;
                    for (const fld of this.folders) {
                        if (fld.folderID.equals(folderID)) {
                            found = true;
                            break;
                        }
                    }
                    if (found) {
                        continue;
                    }
                    const newFolder = new InventoryFolder(this.library, this.agent.inventory.main, this.agent);
                    newFolder.typeDefault = parseInt(folder['type_default'], 10);
                    newFolder.version = parseInt(folder['version'], 10);
                    newFolder.name = String(folder['name']);
                    newFolder.folderID = folderID;
                    newFolder.parentID = new UUID_1.UUID(folder['parent_id']);
                    this.folders.push(newFolder);
                }
                if (folderContents['folders'] && folderContents['folders'][0] && folderContents['folders'][0]['items']) {
                    this.version = folderContents['folders'][0]['version'];
                    this.items = [];
                    for (const item of folderContents['folders'][0]['items']) {
                        const invItem = new InventoryItem_1.InventoryItem(this, this.agent);
                        invItem.assetID = new UUID_1.UUID(item['asset_id'].toString());
                        invItem.inventoryType = item['inv_type'];
                        invItem.name = item['name'];
                        invItem.salePrice = item['sale_info']['sale_price'];
                        invItem.saleType = item['sale_info']['sale_type'];
                        invItem.created = new Date(item['created_at'] * 1000);
                        invItem.parentID = new UUID_1.UUID(item['parent_id'].toString());
                        invItem.flags = item['flags'];
                        invItem.itemID = new UUID_1.UUID(item['item_id'].toString());
                        invItem.description = item['desc'];
                        invItem.type = item['type'];
                        if (item['permissions']['last_owner_id'] === undefined) {
                            // TODO: OpenSim Glitch;
                            item['permissions']['last_owner_id'] = item['permissions']['owner_id'];
                        }
                        invItem.permissions = {
                            baseMask: item['permissions']['base_mask'],
                            groupMask: item['permissions']['group_mask'],
                            nextOwnerMask: item['permissions']['next_owner_mask'],
                            ownerMask: item['permissions']['owner_mask'],
                            everyoneMask: item['permissions']['everyone_mask'],
                            lastOwner: new UUID_1.UUID(item['permissions']['last_owner_id'].toString()),
                            owner: new UUID_1.UUID(item['permissions']['owner_id'].toString()),
                            creator: new UUID_1.UUID(item['permissions']['creator_id'].toString()),
                            group: new UUID_1.UUID(item['permissions']['group_id'].toString())
                        };
                        this.addItem(invItem, false);
                    }
                    this.saveCache().then(() => {
                        resolve();
                    }).catch(() => {
                        // Resolve anyway
                        resolve();
                    });
                }
                else {
                    resolve();
                }
            });
        });
    }
    populate(useCached = true) {
        if (!useCached) {
            return this.populateInternal();
        }
        return new Promise((resolve, reject) => {
            this.loadCache().then(() => {
                resolve();
            }).catch(() => {
                this.populateInternal().then(() => {
                    resolve();
                }).catch((erro) => {
                    reject(erro);
                });
            });
        });
    }
    uploadInventoryAssetLegacy(assetType, inventoryType, data, name, description, flags) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            // Send an AssetUploadRequest and a CreateInventoryRequest simultaneously
            const msg = new AssetUploadRequest_1.AssetUploadRequestMessage();
            const transactionID = UUID_1.UUID.random();
            msg.AssetBlock = {
                StoreLocal: false,
                Type: assetType,
                Tempfile: false,
                TransactionID: transactionID,
                AssetData: Buffer.allocUnsafe(0)
            };
            const callbackID = ++this.callbackID;
            const createMsg = new CreateInventoryItem_1.CreateInventoryItemMessage();
            let wearableType = WearableType_1.WearableType.Shape;
            if (inventoryType === InventoryType_1.InventoryType.Wearable) {
                const wearable = new LLWearable_1.LLWearable(data.toString('utf-8'));
                wearableType = wearable.type;
            }
            else {
                const wearableInFlags = flags & InventoryItemFlags_1.InventoryItemFlags.FlagsSubtypeMask;
                if (wearableInFlags > 0) {
                    wearableType = wearableInFlags;
                }
            }
            createMsg.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: this.agent.currentRegion.circuit.sessionID
            };
            createMsg.InventoryBlock = {
                CallbackID: callbackID,
                FolderID: this.folderID,
                TransactionID: transactionID,
                NextOwnerMask: (1 << 13) | (1 << 14) | (1 << 15) | (1 << 19),
                Type: assetType,
                InvType: inventoryType,
                WearableType: wearableType,
                Name: Utils_1.Utils.StringToBuffer(name),
                Description: Utils_1.Utils.StringToBuffer(description)
            };
            this.agent.currentRegion.circuit.waitForMessage(Message_1.Message.UpdateCreateInventoryItem, 10000, (message) => {
                if (message.InventoryData[0].CallbackID === callbackID) {
                    return FilterResponse_1.FilterResponse.Finish;
                }
                else {
                    return FilterResponse_1.FilterResponse.NoMatch;
                }
            }).then((result) => {
                if (!result.InventoryData || result.InventoryData.length < 1) {
                    reject('Failed to create inventory item for wearable');
                }
                resolve(result.InventoryData[0].ItemID);
            });
            if (data.length + 100 < 1200) {
                msg.AssetBlock.AssetData = data;
                this.agent.currentRegion.circuit.sendMessage(msg, PacketFlags_1.PacketFlags.Reliable);
                this.agent.currentRegion.circuit.sendMessage(createMsg, PacketFlags_1.PacketFlags.Reliable);
            }
            else {
                this.agent.currentRegion.circuit.sendMessage(msg, PacketFlags_1.PacketFlags.Reliable);
                this.agent.currentRegion.circuit.sendMessage(createMsg, PacketFlags_1.PacketFlags.Reliable);
                const result = yield this.agent.currentRegion.circuit.waitForMessage(Message_1.Message.RequestXfer, 10000);
                yield this.agent.currentRegion.circuit.XferFileUp(result.XferID.ID, data);
            }
        }));
    }
    uploadInventoryItem(assetType, inventoryType, data, name, description, flags) {
        return new Promise((resolve, reject) => {
            let wearableType = WearableType_1.WearableType.Shape;
            const wearableInFlags = flags & InventoryItemFlags_1.InventoryItemFlags.FlagsSubtypeMask;
            if (wearableInFlags > 0) {
                wearableType = wearableInFlags;
            }
            const transactionID = UUID_1.UUID.zero();
            const callbackID = ++this.callbackID;
            const msg = new CreateInventoryItem_1.CreateInventoryItemMessage();
            msg.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: this.agent.currentRegion.circuit.sessionID
            };
            msg.InventoryBlock = {
                CallbackID: callbackID,
                FolderID: this.folderID,
                TransactionID: transactionID,
                NextOwnerMask: (1 << 13) | (1 << 14) | (1 << 15) | (1 << 19),
                Type: assetType,
                InvType: inventoryType,
                WearableType: wearableType,
                Name: Utils_1.Utils.StringToBuffer(name),
                Description: Utils_1.Utils.StringToBuffer(description)
            };
            this.agent.currentRegion.circuit.waitForMessage(Message_1.Message.UpdateCreateInventoryItem, 10000, (message) => {
                if (message.InventoryData[0].CallbackID === callbackID) {
                    return FilterResponse_1.FilterResponse.Finish;
                }
                else {
                    return FilterResponse_1.FilterResponse.NoMatch;
                }
            }).then((createInventoryMsg) => {
                switch (inventoryType) {
                    case InventoryType_1.InventoryType.Notecard:
                        {
                            this.agent.currentRegion.caps.capsPostXML('UpdateNotecardAgentInventory', {
                                'item_id': new LLSD.UUID(createInventoryMsg.InventoryData[0].ItemID.toString()),
                            }).then((result) => {
                                if (result['uploader']) {
                                    const uploader = result['uploader'];
                                    this.agent.currentRegion.caps.capsRequestUpload(uploader, data).then((uploadResult) => {
                                        if (uploadResult['state'] && uploadResult['state'] === 'complete') {
                                            const itemID = createInventoryMsg.InventoryData[0].ItemID;
                                            resolve(itemID);
                                        }
                                        else {
                                            reject(new Error('Asset upload failed'));
                                        }
                                    }).catch((err) => {
                                        reject(err);
                                    });
                                }
                                else {
                                    reject(new Error('Invalid response when attempting to request upload URL for notecard'));
                                }
                            }).catch((err) => {
                                reject(err);
                            });
                            break;
                        }
                    case InventoryType_1.InventoryType.Settings:
                        {
                            this.agent.currentRegion.caps.capsPostXML('UpdateSettingsAgentInventory', {
                                'item_id': new LLSD.UUID(createInventoryMsg.InventoryData[0].ItemID.toString()),
                            }).then((result) => {
                                if (result['uploader']) {
                                    const uploader = result['uploader'];
                                    this.agent.currentRegion.caps.capsRequestUpload(uploader, data).then((uploadResult) => {
                                        if (uploadResult['state'] && uploadResult['state'] === 'complete') {
                                            const itemID = createInventoryMsg.InventoryData[0].ItemID;
                                            resolve(itemID);
                                        }
                                        else {
                                            reject(new Error('Asset upload failed'));
                                        }
                                    }).catch((err) => {
                                        reject(err);
                                    });
                                }
                                else {
                                    reject(new Error('Invalid response when attempting to request upload URL for notecard'));
                                }
                            }).catch((err) => {
                                reject(err);
                            });
                            break;
                        }
                    case InventoryType_1.InventoryType.Gesture:
                        {
                            this.agent.currentRegion.caps.isCapAvailable('UpdateGestureAgentInventory').then((available) => {
                                if (available) {
                                    this.agent.currentRegion.caps.capsPostXML('UpdateGestureAgentInventory', {
                                        'item_id': new LLSD.UUID(createInventoryMsg.InventoryData[0].ItemID.toString()),
                                    }).then((result) => {
                                        if (result['uploader']) {
                                            const uploader = result['uploader'];
                                            this.agent.currentRegion.caps.capsRequestUpload(uploader, data).then((uploadResult) => {
                                                if (uploadResult['state'] && uploadResult['state'] === 'complete') {
                                                    const itemID = createInventoryMsg.InventoryData[0].ItemID;
                                                    resolve(itemID);
                                                }
                                                else {
                                                    reject(new Error('Asset upload failed'));
                                                }
                                            }).catch((err) => {
                                                reject(err);
                                            });
                                        }
                                        else {
                                            reject(new Error('Invalid response when attempting to request upload URL for notecard'));
                                        }
                                    }).catch((err) => {
                                        reject(err);
                                    });
                                }
                                else {
                                    this.uploadInventoryAssetLegacy(assetType, inventoryType, data, name, description, flags).then((invItemID) => {
                                        resolve(invItemID);
                                    }).catch((err) => {
                                        reject(err);
                                    });
                                }
                            });
                            break;
                        }
                    case InventoryType_1.InventoryType.Script:
                    case InventoryType_1.InventoryType.LSL:
                        {
                            this.agent.currentRegion.caps.capsPostXML('UpdateScriptAgent', {
                                'item_id': new LLSD.UUID(createInventoryMsg.InventoryData[0].ItemID.toString()),
                                'target': 'mono'
                            }).then((result) => {
                                if (result['uploader']) {
                                    const uploader = result['uploader'];
                                    this.agent.currentRegion.caps.capsRequestUpload(uploader, data).then((uploadResult) => {
                                        if (uploadResult['state'] && uploadResult['state'] === 'complete') {
                                            const itemID = createInventoryMsg.InventoryData[0].ItemID;
                                            resolve(itemID);
                                        }
                                        else {
                                            reject(new Error('Asset upload failed'));
                                        }
                                    }).catch((err) => {
                                        reject(err);
                                    });
                                }
                                else {
                                    reject(new Error('Invalid response when attempting to request upload URL for notecard'));
                                }
                            }).catch((err) => {
                                reject(err);
                            });
                            break;
                        }
                    default:
                        {
                            reject(new Error('Currently unsupported CreateInventoryType: ' + inventoryType));
                        }
                }
            }).catch(() => {
                reject(new Error('Timed out waiting for UpdateCreateInventoryItem'));
            });
            this.agent.currentRegion.circuit.sendMessage(msg, PacketFlags_1.PacketFlags.Reliable);
        });
    }
    uploadAsset(type, inventoryType, data, name, description, flags = InventoryItemFlags_1.InventoryItemFlags.None) {
        return new Promise((resolve, reject) => {
            switch (inventoryType) {
                case InventoryType_1.InventoryType.Wearable:
                case InventoryType_1.InventoryType.Bodypart:
                    // Wearables have to be uploaded using the legacy method and then created
                    this.uploadInventoryAssetLegacy(type, inventoryType, data, name, description, flags).then((invItemID) => {
                        this.agent.inventory.fetchInventoryItem(invItemID).then((item) => {
                            if (item === null) {
                                reject(new Error('Unable to get inventory item'));
                            }
                            else {
                                this.addItem(item, false).then(() => {
                                    resolve(item);
                                });
                            }
                        }).catch((err) => {
                            reject(err);
                        });
                    }).catch((err) => {
                        reject(err);
                    });
                    return;
                case InventoryType_1.InventoryType.Landmark:
                case InventoryType_1.InventoryType.Notecard:
                case InventoryType_1.InventoryType.Gesture:
                case InventoryType_1.InventoryType.Script:
                case InventoryType_1.InventoryType.LSL:
                case InventoryType_1.InventoryType.Settings:
                    // These types must be created first and then modified
                    this.uploadInventoryItem(type, inventoryType, data, name, description, flags).then((invItemID) => {
                        this.agent.inventory.fetchInventoryItem(invItemID).then((item) => {
                            if (item === null) {
                                reject(new Error('Unable to get inventory item'));
                            }
                            else {
                                this.addItem(item, false).then(() => {
                                    resolve(item);
                                });
                            }
                        }).catch((err) => {
                            reject(err);
                        });
                    }).catch((err) => {
                        reject(err);
                    });
                    return;
            }
            Logger_1.Logger.Info('[' + name + ']');
            const httpType = Utils_1.Utils.AssetTypeToHTTPAssetType(type);
            this.agent.currentRegion.caps.capsPostXML('NewFileAgentInventory', {
                'folder_id': new LLSD.UUID(this.folderID.toString()),
                'asset_type': httpType,
                'inventory_type': Utils_1.Utils.HTTPAssetTypeToCapInventoryType(httpType),
                'name': name,
                'description': description,
                'everyone_mask': PermissionMask_1.PermissionMask.All,
                'group_mask': PermissionMask_1.PermissionMask.All,
                'next_owner_mask': PermissionMask_1.PermissionMask.All,
                'expected_upload_cost': 0
            }).then((response) => {
                if (response['state'] === 'upload') {
                    const uploadURL = response['uploader'];
                    this.agent.currentRegion.caps.capsRequestUpload(uploadURL, data).then((responseUpload) => {
                        if (responseUpload['new_inventory_item'] !== undefined) {
                            const invItemID = new UUID_1.UUID(responseUpload['new_inventory_item'].toString());
                            this.agent.inventory.fetchInventoryItem(invItemID).then((item) => {
                                if (item === null) {
                                    reject(new Error('Unable to get inventory item'));
                                }
                                else {
                                    this.addItem(item, false).then(() => {
                                        resolve(item);
                                    });
                                }
                            }).catch((err) => {
                                reject(err);
                            });
                        }
                    }).catch((err) => {
                        reject(err);
                    });
                }
                else if (response['error']) {
                    reject(response['error']['message']);
                }
                else {
                    reject('Unable to upload asset');
                }
            }).catch((err) => {
                console.log('Got err');
                console.log(err);
                reject(err);
            });
        });
    }
    checkCopyright(creatorID) {
        if (!creatorID.equals(this.agent.agentID) && !creatorID.isZero()) {
            throw new Error('Unable to upload - copyright violation');
        }
    }
    findFolder(id) {
        for (const folder of this.folders) {
            if (folder.folderID.equals(id)) {
                return folder;
            }
            const result = folder.findFolder(id);
            if (result !== null) {
                return result;
            }
        }
        return null;
    }
    uploadMesh(name, description, mesh, confirmCostCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            const decodedMesh = yield LLMesh_1.LLMesh.from(mesh);
            this.checkCopyright(decodedMesh.creatorID);
            const faces = [];
            const faceCount = decodedMesh.lodLevels['high_lod'].length;
            for (let x = 0; x < faceCount; x++) {
                faces.push({
                    'diffuse_color': [1.000000000000001, 1.000000000000001, 1.000000000000001, 1.000000000000001],
                    'fullbright': false
                });
            }
            const prim = {
                'face_list': faces,
                'position': [0.000000000000001, 0.000000000000001, 0.000000000000001],
                'rotation': [0.000000000000001, 0.000000000000001, 0.000000000000001, 1.000000000000001],
                'scale': [2.000000000000001, 2.000000000000001, 2.000000000000001],
                'material': 3,
                'physics_shape_type': 2,
                'mesh': 0
            };
            const assetResources = {
                'instance_list': [prim],
                'mesh_list': [new LLSD.Binary(Array.from(mesh))],
                'texture_list': [],
                'metric': 'MUT_Unspecified'
            };
            const uploadMap = {
                'name': String(name),
                'description': String(description),
                'asset_resources': assetResources,
                'asset_type': 'mesh',
                'inventory_type': 'object',
                'folder_id': new LLSD.UUID(this.folderID.toString()),
                'texture_folder_id': new LLSD.UUID(yield this.agent.inventory.findFolderForType(FolderType_1.FolderType.Texture)),
                'everyone_mask': PermissionMask_1.PermissionMask.All,
                'group_mask': PermissionMask_1.PermissionMask.All,
                'next_owner_mask': PermissionMask_1.PermissionMask.All
            };
            let result;
            try {
                result = yield this.agent.currentRegion.caps.capsPostXML('NewFileAgentInventory', uploadMap);
            }
            catch (error) {
                console.error(error);
            }
            if (result['state'] === 'upload' && result['upload_price'] !== undefined) {
                const cost = result['upload_price'];
                if (yield confirmCostCallback(cost)) {
                    const uploader = result['uploader'];
                    const uploadResult = yield this.agent.currentRegion.caps.capsPerformXMLPost(uploader, assetResources);
                    if (uploadResult['new_inventory_item'] && uploadResult['new_asset']) {
                        const inventoryItem = new UUID_1.UUID(uploadResult['new_inventory_item'].toString());
                        const item = yield this.agent.inventory.fetchInventoryItem(inventoryItem);
                        if (item !== null) {
                            item.assetID = new UUID_1.UUID(uploadResult['new_asset'].toString());
                            yield this.addItem(item, false);
                            return item;
                        }
                        else {
                            throw new Error('Unable to locate inventory item following mesh upload');
                        }
                    }
                    else {
                        throw new Error('Upload failed - no new inventory item returned');
                    }
                }
                throw new Error('Upload cost declined');
            }
            else {
                console.log(result);
                console.log(JSON.stringify(result.error));
                throw new Error('Upload failed');
            }
        });
    }
}
exports.InventoryFolder = InventoryFolder;
//# sourceMappingURL=InventoryFolder.js.map