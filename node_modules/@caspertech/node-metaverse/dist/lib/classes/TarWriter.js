"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TarWriter = void 0;
const fs = require("fs");
const stream_1 = require("stream");
class TarWriter extends stream_1.Transform {
    constructor() {
        super(...arguments);
        this.thisFileSize = 0;
        this.fileActive = false;
    }
    newFile(archivePath, realPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.fileActive) {
                this.endFile();
            }
            const stat = fs.statSync(realPath);
            const buf = Buffer.from(archivePath, 'ascii');
            this.writeHeader(this.chopString('././@LongName', 100), stat.mode, stat.uid, stat.gid, buf.length, stat.mtime, 'L');
            this.thisFileSize = buf.length;
            yield this.pipeFromBuffer(buf);
            this.endFile();
            this.writeHeader(this.chopString(archivePath, 100), stat.mode, stat.uid, stat.gid, stat.size, stat.mtime, '0');
            this.thisFileSize = stat.size;
            this.fileActive = true;
        });
    }
    pipeFromBuffer(buf) {
        return __awaiter(this, void 0, void 0, function* () {
            const readableInstanceStream = new stream_1.Readable({
                read() {
                    this.push(buf);
                    this.push(null);
                }
            });
            return this.pipeFrom(readableInstanceStream);
        });
    }
    pipeFrom(str) {
        return new Promise((resolve, reject) => {
            str.on('error', (err) => {
                reject(err);
            });
            str.on('end', () => {
                resolve();
            });
            str.pipe(this, { end: false });
        });
    }
    writeHeader(fileName, mode, uid, gid, fileSize, mTime, fileType) {
        return __awaiter(this, void 0, void 0, function* () {
            const header = Buffer.alloc(512);
            const name = this.chopString(fileName, 100);
            header.write(name, 0, (name.length <= 100 ? name.length : 100));
            this.octalBuf(mode, 8).copy(header, 100);
            this.octalBuf(uid, 8).copy(header, 108);
            this.octalBuf(gid, 8).copy(header, 116);
            this.octalBuf(fileSize, 12).copy(header, 124);
            this.octalBuf(Math.floor(mTime.getTime() / 1000), 12).copy(header, 136);
            header.write(fileType, 156, 1);
            let sum = 8 * 32;
            for (let x = 0; x < 512; x++) {
                if (x < 148 || x > 155) {
                    sum += header.readUInt8(x);
                }
            }
            let sumStr = this.octalString(sum, 6);
            while (sumStr.length < 6) {
                sumStr = '0' + sumStr;
            }
            sumStr += '\0 ';
            header.write(sumStr, 148, sumStr.length);
            return this.pipeFromBuffer(header);
        });
    }
    endFile() {
        return __awaiter(this, void 0, void 0, function* () {
            const finalSize = Math.ceil(this.thisFileSize / 512) * 512;
            const remainingSize = finalSize - this.thisFileSize;
            const buf = Buffer.alloc(remainingSize);
            yield this.pipeFromBuffer(buf);
            this.fileActive = false;
        });
    }
    _transform(chunk, encoding, callback) {
        this.push(chunk, encoding);
        callback();
    }
    chopString(str, maxLength) {
        return str.substr(0, maxLength - 1);
    }
    octalBuf(num, length) {
        const buf = Buffer.alloc(length - 1, '0');
        const result = this.chopString(Math.floor(num).toString(8), length);
        buf.write(result, length - (result.length + 1), result.length);
        return buf;
    }
    octalString(num, length) {
        return this.octalBuf(num, length).toString('ascii');
    }
}
exports.TarWriter = TarWriter;
//# sourceMappingURL=TarWriter.js.map