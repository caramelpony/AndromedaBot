"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InventoryCommands = void 0;
const CommandsBase_1 = require("./CommandsBase");
const InstantMessageDialog_1 = require("../../enums/InstantMessageDialog");
const ImprovedInstantMessage_1 = require("../messages/ImprovedInstantMessage");
const Utils_1 = require("../Utils");
const UUID_1 = require("../UUID");
const Vector3_1 = require("../Vector3");
const PacketFlags_1 = require("../../enums/PacketFlags");
const ChatSourceType_1 = require("../../enums/ChatSourceType");
class InventoryCommands extends CommandsBase_1.CommandsBase {
    getInventoryRoot() {
        return this.agent.inventory.getRootFolderMain();
    }
    getLibraryRoot() {
        return this.agent.inventory.getRootFolderLibrary();
    }
    respondToInventoryOffer(event, response) {
        return __awaiter(this, void 0, void 0, function* () {
            const agentName = this.agent.firstName + ' ' + this.agent.lastName;
            const im = new ImprovedInstantMessage_1.ImprovedInstantMessageMessage();
            const folderType = event.type;
            const folder = this.agent.inventory.findFolderForType(folderType);
            const binary = Buffer.allocUnsafe(16);
            folder.writeToBuffer(binary, 0);
            im.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: this.circuit.sessionID
            };
            im.MessageBlock = {
                FromGroup: false,
                ToAgentID: event.from,
                ParentEstateID: 0,
                RegionID: UUID_1.UUID.zero(),
                Position: Vector3_1.Vector3.getZero(),
                Offline: 0,
                Dialog: response,
                ID: event.requestID,
                Timestamp: Math.floor(new Date().getTime() / 1000),
                FromAgentName: Utils_1.Utils.StringToBuffer(agentName),
                Message: Utils_1.Utils.StringToBuffer(''),
                BinaryBucket: binary
            };
            im.EstateBlock = {
                EstateID: 0
            };
            const sequenceNo = this.circuit.sendMessage(im, PacketFlags_1.PacketFlags.Reliable);
            return yield this.circuit.waitForAck(sequenceNo, 10000);
        });
    }
    getInventoryItem(item) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof item === 'string') {
                item = new UUID_1.UUID(item);
            }
            const result = yield this.currentRegion.agent.inventory.fetchInventoryItem(item);
            if (result === null) {
                throw new Error('Unable to get inventory item');
            }
            else {
                return result;
            }
        });
    }
    acceptInventoryOffer(event) {
        return __awaiter(this, void 0, void 0, function* () {
            if (event.source === ChatSourceType_1.ChatSourceType.Object) {
                return yield this.respondToInventoryOffer(event, InstantMessageDialog_1.InstantMessageDialog.TaskInventoryAccepted);
            }
            else {
                return yield this.respondToInventoryOffer(event, InstantMessageDialog_1.InstantMessageDialog.InventoryAccepted);
            }
        });
    }
    rejectInventoryOffer(event) {
        return __awaiter(this, void 0, void 0, function* () {
            if (event.source === ChatSourceType_1.ChatSourceType.Object) {
                return yield this.respondToInventoryOffer(event, InstantMessageDialog_1.InstantMessageDialog.TaskInventoryDeclined);
            }
            else {
                return yield this.respondToInventoryOffer(event, InstantMessageDialog_1.InstantMessageDialog.InventoryDeclined);
            }
        });
    }
}
exports.InventoryCommands = InventoryCommands;
//# sourceMappingURL=InventoryCommands.js.map