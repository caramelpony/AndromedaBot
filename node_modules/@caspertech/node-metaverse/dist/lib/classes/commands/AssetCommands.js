"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetCommands = void 0;
const CommandsBase_1 = require("./CommandsBase");
const UUID_1 = require("../UUID");
const LLSD = require("@caspertech/llsd");
const Utils_1 = require("../Utils");
const TransferRequest_1 = require("../messages/TransferRequest");
const TransferChannelType_1 = require("../../enums/TransferChannelType");
const TransferSourceTypes_1 = require("../../enums/TransferSourceTypes");
const Message_1 = require("../../enums/Message");
const AssetType_1 = require("../../enums/AssetType");
const PacketFlags_1 = require("../../enums/PacketFlags");
const TransferStatus_1 = require("../../enums/TransferStatus");
const Material_1 = require("../public/Material");
const FilterResponse_1 = require("../../enums/FilterResponse");
const LLLindenText_1 = require("../LLLindenText");
class AssetCommands extends CommandsBase_1.CommandsBase {
    downloadAsset(type, uuid) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof uuid === 'string') {
                uuid = new UUID_1.UUID(uuid);
            }
            try {
                const result = yield this.currentRegion.caps.downloadAsset(uuid, type);
                if (result.toString('utf-8').trim() === 'Not found!') {
                    throw new Error('Asset not found');
                }
                else if (result.toString('utf-8').trim() === 'Incorrect Syntax') {
                    throw new Error('Invalid Syntax');
                }
                return result;
            }
            catch (error) {
                // Fall back to old asset transfer
                const transferParams = Buffer.allocUnsafe(20);
                uuid.writeToBuffer(transferParams, 0);
                transferParams.writeInt32LE(parseInt(type, 10), 16);
                return this.transfer(TransferChannelType_1.TransferChannelType.Asset, TransferSourceTypes_1.TransferSourceType.Asset, false, transferParams);
            }
        });
    }
    copyInventoryFromNotecard(notecardID, folder, itemID, objectID = UUID_1.UUID.zero()) {
        return __awaiter(this, void 0, void 0, function* () {
            const gotCap = yield this.currentRegion.caps.isCapAvailable('CopyInventoryFromNotecard');
            if (gotCap) {
                const callbackID = Math.floor(Math.random() * 2147483647);
                const request = {
                    'callback-id': callbackID,
                    'folder-id': new LLSD.UUID(folder.folderID.toString()),
                    'item-id': new LLSD.UUID(itemID.toString()),
                    'notecard-id': new LLSD.UUID(notecardID.toString()),
                    'object-id': new LLSD.UUID(objectID.toString())
                };
                this.currentRegion.caps.capsPostXML('CopyInventoryFromNotecard', request).then(() => {
                }).catch((err) => {
                    throw err;
                });
                const evt = yield Utils_1.Utils.waitOrTimeOut(this.currentRegion.clientEvents.onBulkUpdateInventoryEvent, 10000, (event) => {
                    for (const item of event.itemData) {
                        if (item.callbackID === callbackID) {
                            return FilterResponse_1.FilterResponse.Finish;
                        }
                    }
                    return FilterResponse_1.FilterResponse.NoMatch;
                });
                for (const item of evt.itemData) {
                    if (item.callbackID === callbackID) {
                        return item;
                    }
                }
                throw new Error('No match');
            }
            else {
                throw new Error('CopyInventoryFromNotecard cap not available');
            }
        });
    }
    transfer(channelType, sourceType, priority, transferParams, outAssetID) {
        return new Promise((resolve, reject) => {
            const transferID = UUID_1.UUID.random();
            const msg = new TransferRequest_1.TransferRequestMessage();
            msg.TransferInfo = {
                TransferID: transferID,
                ChannelType: channelType,
                SourceType: sourceType,
                Priority: 100.0 + (priority ? 1.0 : 0.0),
                Params: transferParams
            };
            let gotInfo = true;
            let expectedSize = 0;
            const packets = {};
            let subscription = undefined;
            let timeout;
            function cleanup() {
                if (subscription !== undefined) {
                    subscription.unsubscribe();
                    subscription = undefined;
                }
                if (timeout !== undefined) {
                    clearTimeout(timeout);
                    timeout = undefined;
                }
            }
            function placeTimeout() {
                timeout = setTimeout(() => {
                    cleanup();
                    reject(new Error('Timeout'));
                }, 10000);
            }
            function resetTimeout() {
                if (timeout !== undefined) {
                    clearTimeout(timeout);
                }
                placeTimeout();
            }
            subscription = this.circuit.subscribeToMessages([
                Message_1.Message.TransferInfo,
                Message_1.Message.TransferAbort,
                Message_1.Message.TransferPacket
            ], (packet) => {
                try {
                    switch (packet.message.id) {
                        case Message_1.Message.TransferPacket:
                            {
                                const messg = packet.message;
                                if (!messg.TransferData.TransferID.equals(transferID)) {
                                    return;
                                }
                                resetTimeout();
                                packets[messg.TransferData.Packet] = messg.TransferData.Data;
                                switch (messg.TransferData.Status) {
                                    case TransferStatus_1.TransferStatus.Abort:
                                        cleanup();
                                        reject(new Error('Transfer Aborted'));
                                        break;
                                    case TransferStatus_1.TransferStatus.Error:
                                        cleanup();
                                        reject(new Error('Error'));
                                        break;
                                    case TransferStatus_1.TransferStatus.Skip:
                                        console.error('TransferPacket: Skip! not sure what this means');
                                        break;
                                    case TransferStatus_1.TransferStatus.InsufficientPermissions:
                                        cleanup();
                                        reject(new Error('Insufficient Permissions'));
                                        break;
                                    case TransferStatus_1.TransferStatus.NotFound:
                                        cleanup();
                                        reject(new Error('Not Found'));
                                        break;
                                }
                                break;
                            }
                        case Message_1.Message.TransferInfo:
                            {
                                const messg = packet.message;
                                if (!messg.TransferInfo.TransferID.equals(transferID)) {
                                    return;
                                }
                                resetTimeout();
                                const status = messg.TransferInfo.Status;
                                switch (status) {
                                    case TransferStatus_1.TransferStatus.OK:
                                        expectedSize = messg.TransferInfo.Size;
                                        gotInfo = true;
                                        if (outAssetID !== undefined) {
                                            outAssetID.assetID = new UUID_1.UUID(messg.TransferInfo.Params, 80);
                                        }
                                        break;
                                    case TransferStatus_1.TransferStatus.Abort:
                                        cleanup();
                                        reject(new Error('Transfer Aborted'));
                                        break;
                                    case TransferStatus_1.TransferStatus.Error:
                                        cleanup();
                                        reject(new Error('Error downloading asset'));
                                        // See if we get anything else
                                        break;
                                    case TransferStatus_1.TransferStatus.Skip:
                                        console.error('TransferInfo: Skip! not sure what this means');
                                        break;
                                    case TransferStatus_1.TransferStatus.InsufficientPermissions:
                                        cleanup();
                                        reject(new Error('Insufficient Permissions'));
                                        break;
                                    case TransferStatus_1.TransferStatus.NotFound:
                                        cleanup();
                                        reject(new Error('Not Found'));
                                        break;
                                }
                                break;
                            }
                        case Message_1.Message.TransferAbort:
                            {
                                const messg = packet.message;
                                if (!messg.TransferInfo.TransferID.equals(transferID)) {
                                    return;
                                }
                                resetTimeout();
                                cleanup();
                                reject(new Error('Transfer Aborted'));
                                return;
                            }
                    }
                    if (gotInfo) {
                        let gotSize = 0;
                        for (const packetNum of Object.keys(packets)) {
                            const pn = parseInt(packetNum, 10);
                            gotSize += packets[pn].length;
                        }
                        if (gotSize >= expectedSize) {
                            const packetNumbers = Object.keys(packets).sort((a, b) => {
                                return parseInt(a, 10) - parseInt(b, 10);
                            });
                            const buffers = [];
                            for (const pn of packetNumbers) {
                                buffers.push(packets[parseInt(pn, 10)]);
                            }
                            cleanup();
                            resolve(Buffer.concat(buffers));
                        }
                    }
                }
                catch (error) {
                    cleanup();
                    reject(error);
                }
            });
            placeTimeout();
            this.circuit.sendMessage(msg, PacketFlags_1.PacketFlags.Reliable);
        });
    }
    downloadInventoryAsset(itemID, ownerID, type, priority, objectID = UUID_1.UUID.zero(), assetID = UUID_1.UUID.zero(), outAssetID, sourceType = TransferSourceTypes_1.TransferSourceType.SimInventoryItem, channelType = TransferChannelType_1.TransferChannelType.Asset) {
        return new Promise((resolve, reject) => {
            if (type === AssetType_1.AssetType.Notecard && assetID.isZero()) {
                // Empty notecard
                const note = new LLLindenText_1.LLLindenText();
                resolve(note.toAsset());
            }
            const transferParams = Buffer.allocUnsafe(100);
            let pos = 0;
            this.agent.agentID.writeToBuffer(transferParams, pos);
            pos = pos + 16;
            this.circuit.sessionID.writeToBuffer(transferParams, pos);
            pos = pos + 16;
            ownerID.writeToBuffer(transferParams, pos);
            pos = pos + 16;
            objectID.writeToBuffer(transferParams, pos);
            pos = pos + 16;
            itemID.writeToBuffer(transferParams, pos);
            pos = pos + 16;
            assetID.writeToBuffer(transferParams, pos);
            pos = pos + 16;
            transferParams.writeInt32LE(type, pos);
            this.transfer(channelType, sourceType, priority, transferParams, outAssetID).then((result) => {
                resolve(result);
            }).catch((err) => {
                reject(err);
            });
        });
    }
    getMaterialsLimited(uuidArray, uuids) {
        return __awaiter(this, void 0, void 0, function* () {
            const binary = LLSD.LLSD.formatBinary(uuidArray);
            const res = yield Utils_1.Utils.deflate(Buffer.from(binary.toArray()));
            const result = yield this.currentRegion.caps.capsPostXML('RenderMaterials', {
                'Zipped': LLSD.LLSD.asBinary(res.toString('base64'))
            });
            const resultZipped = Buffer.from(result['Zipped'].octets);
            const reslt = yield Utils_1.Utils.inflate(resultZipped);
            const binData = new LLSD.Binary(Array.from(reslt), 'BASE64');
            const llsdResult = LLSD.LLSD.parseBinary(binData);
            let obj = [];
            if (llsdResult.result) {
                obj = llsdResult.result;
            }
            if (obj.length > 0) {
                for (const mat of obj) {
                    if (mat['ID']) {
                        const nbuf = Buffer.from(mat['ID'].toArray());
                        const nuuid = new UUID_1.UUID(nbuf, 0).toString();
                        if (uuids[nuuid] !== undefined) {
                            if (mat['Material']) {
                                uuids[nuuid] = Material_1.Material.fromLLSDObject(mat['Material']);
                            }
                        }
                    }
                }
            }
            else {
                throw new Error('Material data not found');
            }
        });
    }
    getMaterials(uuids) {
        return __awaiter(this, void 0, void 0, function* () {
            let uuidArray = [];
            let submittedUUIDS = {};
            for (const uuid of Object.keys(uuids)) {
                if (uuidArray.length > 32) {
                    try {
                        yield this.getMaterialsLimited(uuidArray, submittedUUIDS);
                        for (const uu of Object.keys(submittedUUIDS)) {
                            if (submittedUUIDS[uu] !== null) {
                                uuids[uu] = submittedUUIDS[uu];
                            }
                        }
                    }
                    catch (error) {
                        console.error(error);
                    }
                    uuidArray = [];
                    submittedUUIDS = {};
                }
                if (!submittedUUIDS[uuid]) {
                    submittedUUIDS[uuid] = uuids[uuid];
                    uuidArray.push(new LLSD.Binary(Array.from(new UUID_1.UUID(uuid).getBuffer())));
                }
            }
            try {
                yield this.getMaterialsLimited(uuidArray, submittedUUIDS);
                for (const uu of Object.keys(submittedUUIDS)) {
                    if (submittedUUIDS[uu] !== null) {
                        uuids[uu] = submittedUUIDS[uu];
                    }
                }
            }
            catch (error) {
                console.error(error);
            }
        });
    }
}
exports.AssetCommands = AssetCommands;
//# sourceMappingURL=AssetCommands.js.map