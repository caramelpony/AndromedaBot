"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParcelCommands = void 0;
const CommandsBase_1 = require("./CommandsBase");
const ParcelInfoRequest_1 = require("../messages/ParcelInfoRequest");
const UUID_1 = require("../UUID");
const Message_1 = require("../../enums/Message");
const FilterResponse_1 = require("../../enums/FilterResponse");
const Utils_1 = require("../Utils");
const PacketFlags_1 = require("../../enums/PacketFlags");
const Vector3_1 = require("../Vector3");
const LandStatRequest_1 = require("../messages/LandStatRequest");
// This class was added to provide a new "Category" of commands, since we don't have any parcel specific functionality yet.
class ParcelCommands extends CommandsBase_1.CommandsBase {
    getParcelInfo(parcelID) {
        return __awaiter(this, void 0, void 0, function* () {
            // Since this is a userspace command, we are kind and accept the UUID as a string.
            // If it's a string, then we convert to UUID.
            if (typeof parcelID === 'string') {
                parcelID = new UUID_1.UUID(parcelID);
            }
            // Create a new ParcelInfoRequest message, which is the type that we want
            const msg = new ParcelInfoRequest_1.ParcelInfoRequestMessage();
            // Fill the message with the correct data (see ParcelInfoRequest.ts)
            msg.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: this.circuit.sessionID
            };
            msg.Data = {
                ParcelID: parcelID
            };
            // Shove the message into our send queue
            this.circuit.sendMessage(msg, PacketFlags_1.PacketFlags.Reliable);
            // And wait for a reply. It's okay to do this after we send since we haven't yielded until this subscription is set up.
            const parcelInfoReply = (yield this.circuit.waitForMessage(Message_1.Message.ParcelInfoRequest, 10000, (replyMessage) => {
                // This function is here as a filter to ensure we get the correct message.
                // It compares every incoming ParcelInfoReplyMessage, checks the ParcelID and compares to the one we requested.
                if (replyMessage.Data.ParcelID.equals(parcelID)) {
                    // We received a reply for the ParcelID that we requested info for, so return with "Finish" because we don't want any more after this.
                    // If we are expecting multiple replies we can reply with FilterResponse.Match which will keep the listener open.
                    return FilterResponse_1.FilterResponse.Finish;
                }
                return FilterResponse_1.FilterResponse.NoMatch;
            }));
            // parcelInfoReply will now contain the message that we issued a "Finish" response for.
            // In the event of an error or timeout, an exception would have been thrown and this code won't be reached.
            // Rather than simply returning the message, we convert the data into an "Event" which is supposed to be
            // a bit more user friendly for the user.
            return new class {
                constructor() {
                    this.OwnerID = parcelInfoReply.Data.OwnerID;
                    // Because Data.Name is a buffer, we have a helper function to decode it.
                    this.ParcelName = Utils_1.Utils.BufferToStringSimple(parcelInfoReply.Data.Name);
                    this.ParcelDescription = Utils_1.Utils.BufferToStringSimple(parcelInfoReply.Data.Desc);
                    this.Area = parcelInfoReply.Data.ActualArea;
                    this.BillableArea = parcelInfoReply.Data.BillableArea;
                    this.Flags = parcelInfoReply.Data.Flags;
                    this.GlobalCoordinates = new Vector3_1.Vector3([parcelInfoReply.Data.GlobalX, parcelInfoReply.Data.GlobalY, parcelInfoReply.Data.GlobalZ]);
                    this.RegionName = Utils_1.Utils.BufferToStringSimple(parcelInfoReply.Data.SimName);
                    this.SnapshotID = parcelInfoReply.Data.SnapshotID;
                    this.Traffic = parcelInfoReply.Data.Dwell;
                    this.SalePrice = parcelInfoReply.Data.SalePrice;
                    this.AuctionID = parcelInfoReply.Data.AuctionID;
                }
            };
        });
    }
    getLandStats(parcelID, reportType, flags, filter) {
        return __awaiter(this, void 0, void 0, function* () {
            if (parcelID instanceof UUID_1.UUID) {
                parcelID = parcelID.toString();
            }
            if (typeof parcelID === 'string') {
                // Find the parcel localID
                const parcels = yield this.bot.clientCommands.region.getParcels();
                for (const parcel of parcels) {
                    if (parcel.ParcelID.toString() === parcelID) {
                        parcelID = parcel.LocalID;
                        break;
                    }
                }
            }
            if (typeof parcelID !== 'number') {
                throw new Error('Unable to locate parcel');
            }
            if (filter === undefined) {
                filter = '';
            }
            const msg = new LandStatRequest_1.LandStatRequestMessage();
            msg.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: this.circuit.sessionID
            };
            msg.RequestData = {
                ParcelLocalID: parcelID,
                ReportType: reportType,
                Filter: Utils_1.Utils.StringToBuffer(filter),
                RequestFlags: flags
            };
            this.circuit.sendMessage(msg, PacketFlags_1.PacketFlags.Reliable);
            return Utils_1.Utils.waitOrTimeOut(this.currentRegion.clientEvents.onLandStatReplyEvent, 10000);
        });
    }
}
exports.ParcelCommands = ParcelCommands;
//# sourceMappingURL=ParcelCommands.js.map