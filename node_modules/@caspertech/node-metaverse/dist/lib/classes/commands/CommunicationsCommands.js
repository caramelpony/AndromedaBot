"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommunicationsCommands = void 0;
const LLSD = require("@caspertech/llsd");
const AssetType_1 = require("../../enums/AssetType");
const ChatType_1 = require("../../enums/ChatType");
const FilterResponse_1 = require("../../enums/FilterResponse");
const InstantMessageDialog_1 = require("../../enums/InstantMessageDialog");
const InstantMessageOnline_1 = require("../../enums/InstantMessageOnline");
const PacketFlags_1 = require("../../enums/PacketFlags");
const InventoryItem_1 = require("../InventoryItem");
const ChatFromViewer_1 = require("../messages/ChatFromViewer");
const ImprovedInstantMessage_1 = require("../messages/ImprovedInstantMessage");
const ScriptDialogReply_1 = require("../messages/ScriptDialogReply");
const StartLure_1 = require("../messages/StartLure");
const Utils_1 = require("../Utils");
const UUID_1 = require("../UUID");
const Vector3_1 = require("../Vector3");
const CommandsBase_1 = require("./CommandsBase");
class CommunicationsCommands extends CommandsBase_1.CommandsBase {
    giveInventory(to, itemOrFolder) {
        return __awaiter(this, void 0, void 0, function* () {
            const circuit = this.circuit;
            if (typeof to === 'string') {
                to = new UUID_1.UUID(to);
            }
            let bucket = undefined;
            if (itemOrFolder instanceof InventoryItem_1.InventoryItem) {
                bucket = Buffer.allocUnsafe(17);
                bucket.writeUInt8(itemOrFolder.type, 0);
                itemOrFolder.itemID.writeToBuffer(bucket, 1);
            }
            else {
                yield itemOrFolder.populate(false);
                bucket = Buffer.allocUnsafe(17 * (itemOrFolder.items.length + 1));
                let offset = 0;
                bucket.writeUInt8(AssetType_1.AssetType.Folder, offset++);
                itemOrFolder.folderID.writeToBuffer(bucket, offset);
                offset += 16;
                for (const item of itemOrFolder.items) {
                    bucket.writeUInt8(item.type, offset++);
                    item.itemID.writeToBuffer(bucket, offset);
                    offset += 16;
                }
            }
            const agentName = this.agent.firstName + ' ' + this.agent.lastName;
            const im = new ImprovedInstantMessage_1.ImprovedInstantMessageMessage();
            im.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: circuit.sessionID
            };
            im.MessageBlock = {
                FromGroup: false,
                ToAgentID: to,
                ParentEstateID: 0,
                RegionID: UUID_1.UUID.zero(),
                Position: Vector3_1.Vector3.getZero(),
                Offline: InstantMessageOnline_1.InstantMessageOnline.Online,
                Dialog: InstantMessageDialog_1.InstantMessageDialog.InventoryOffered,
                ID: UUID_1.UUID.random(),
                Timestamp: Math.floor(new Date().getTime() / 1000),
                FromAgentName: Utils_1.Utils.StringToBuffer(agentName),
                Message: Utils_1.Utils.StringToBuffer(itemOrFolder.name),
                BinaryBucket: bucket
            };
            im.EstateBlock = {
                EstateID: 0
            };
            const sequenceNo = circuit.sendMessage(im, PacketFlags_1.PacketFlags.Reliable);
            return yield circuit.waitForAck(sequenceNo, 10000);
        });
    }
    sendInstantMessage(to, message) {
        return __awaiter(this, void 0, void 0, function* () {
            const circuit = this.circuit;
            if (typeof to === 'string') {
                to = new UUID_1.UUID(to);
            }
            const agentName = this.agent.firstName + ' ' + this.agent.lastName;
            const im = new ImprovedInstantMessage_1.ImprovedInstantMessageMessage();
            im.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: circuit.sessionID
            };
            im.MessageBlock = {
                FromGroup: false,
                ToAgentID: to,
                ParentEstateID: 0,
                RegionID: UUID_1.UUID.zero(),
                Position: Vector3_1.Vector3.getZero(),
                Offline: 1,
                Dialog: 0,
                ID: UUID_1.UUID.zero(),
                Timestamp: Math.floor(new Date().getTime() / 1000),
                FromAgentName: Utils_1.Utils.StringToBuffer(agentName),
                Message: Utils_1.Utils.StringToBuffer(message),
                BinaryBucket: Buffer.allocUnsafe(0)
            };
            im.EstateBlock = {
                EstateID: 0
            };
            const sequenceNo = circuit.sendMessage(im, PacketFlags_1.PacketFlags.Reliable);
            return yield circuit.waitForAck(sequenceNo, 10000);
        });
    }
    nearbyChat(message, type, channel) {
        return __awaiter(this, void 0, void 0, function* () {
            if (channel === undefined) {
                channel = 0;
            }
            const cfv = new ChatFromViewer_1.ChatFromViewerMessage();
            cfv.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: this.circuit.sessionID
            };
            cfv.ChatData = {
                Message: Utils_1.Utils.StringToBuffer(message),
                Type: type,
                Channel: channel
            };
            const sequenceNo = this.circuit.sendMessage(cfv, PacketFlags_1.PacketFlags.Reliable);
            return yield this.circuit.waitForAck(sequenceNo, 10000);
        });
    }
    say(message, channel) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.nearbyChat(message, ChatType_1.ChatType.Normal, channel);
        });
    }
    whisper(message, channel) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.nearbyChat(message, ChatType_1.ChatType.Whisper, channel);
        });
    }
    shout(message, channel) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.nearbyChat(message, ChatType_1.ChatType.Shout, channel);
        });
    }
    startTypingLocal() {
        return __awaiter(this, void 0, void 0, function* () {
            const cfv = new ChatFromViewer_1.ChatFromViewerMessage();
            cfv.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: this.circuit.sessionID
            };
            cfv.ChatData = {
                Message: Buffer.allocUnsafe(0),
                Type: ChatType_1.ChatType.StartTyping,
                Channel: 0
            };
            const sequenceNo = this.circuit.sendMessage(cfv, PacketFlags_1.PacketFlags.Reliable);
            return yield this.circuit.waitForAck(sequenceNo, 10000);
        });
    }
    sendTeleport(target, message) {
        if (typeof target === 'string') {
            target = new UUID_1.UUID(target);
        }
        if (message === undefined) {
            message = 'Join me in ' + this.currentRegion.regionName;
        }
        const p = new StartLure_1.StartLureMessage();
        p.AgentData = {
            AgentID: this.agent.agentID,
            SessionID: this.circuit.sessionID
        };
        p.Info = {
            LureType: 0,
            Message: Utils_1.Utils.StringToBuffer(message)
        };
        p.TargetData = [{
                TargetID: target
            }];
        const sequenceNo = this.circuit.sendMessage(p, PacketFlags_1.PacketFlags.Reliable);
        return this.circuit.waitForAck(sequenceNo, 10000);
    }
    stopTypingLocal() {
        return __awaiter(this, void 0, void 0, function* () {
            const cfv = new ChatFromViewer_1.ChatFromViewerMessage();
            cfv.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: this.circuit.sessionID
            };
            cfv.ChatData = {
                Message: Buffer.allocUnsafe(0),
                Type: ChatType_1.ChatType.StopTyping,
                Channel: 0
            };
            const sequenceNo = this.circuit.sendMessage(cfv, PacketFlags_1.PacketFlags.Reliable);
            return yield this.circuit.waitForAck(sequenceNo, 10000);
        });
    }
    startTypingIM(to) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof to === 'string') {
                to = new UUID_1.UUID(to);
            }
            const circuit = this.circuit;
            const agentName = this.agent.firstName + ' ' + this.agent.lastName;
            const im = new ImprovedInstantMessage_1.ImprovedInstantMessageMessage();
            im.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: circuit.sessionID
            };
            im.MessageBlock = {
                FromGroup: false,
                ToAgentID: to,
                ParentEstateID: 0,
                RegionID: UUID_1.UUID.zero(),
                Position: Vector3_1.Vector3.getZero(),
                Offline: 0,
                Dialog: InstantMessageDialog_1.InstantMessageDialog.StartTyping,
                ID: UUID_1.UUID.zero(),
                Timestamp: Math.floor(new Date().getTime() / 1000),
                FromAgentName: Utils_1.Utils.StringToBuffer(agentName),
                Message: Utils_1.Utils.StringToBuffer(''),
                BinaryBucket: Buffer.allocUnsafe(0)
            };
            im.EstateBlock = {
                EstateID: 0
            };
            const sequenceNo = circuit.sendMessage(im, PacketFlags_1.PacketFlags.Reliable);
            return yield circuit.waitForAck(sequenceNo, 10000);
        });
    }
    stopTypingIM(to) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof to === 'string') {
                to = new UUID_1.UUID(to);
            }
            const circuit = this.circuit;
            const agentName = this.agent.firstName + ' ' + this.agent.lastName;
            const im = new ImprovedInstantMessage_1.ImprovedInstantMessageMessage();
            im.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: circuit.sessionID
            };
            im.MessageBlock = {
                FromGroup: false,
                ToAgentID: to,
                ParentEstateID: 0,
                RegionID: UUID_1.UUID.zero(),
                Position: Vector3_1.Vector3.getZero(),
                Offline: 0,
                Dialog: InstantMessageDialog_1.InstantMessageDialog.StopTyping,
                ID: UUID_1.UUID.zero(),
                Timestamp: Math.floor(new Date().getTime() / 1000),
                FromAgentName: Utils_1.Utils.StringToBuffer(agentName),
                Message: Utils_1.Utils.StringToBuffer(''),
                BinaryBucket: Buffer.allocUnsafe(0)
            };
            im.EstateBlock = {
                EstateID: 0
            };
            const sequenceNo = circuit.sendMessage(im, PacketFlags_1.PacketFlags.Reliable);
            return yield circuit.waitForAck(sequenceNo, 10000);
        });
    }
    typeInstantMessage(to, message, thinkingTime, charactersPerSecond) {
        return new Promise((resolve, reject) => {
            if (thinkingTime === undefined) {
                thinkingTime = 2000;
            }
            setTimeout(() => {
                if (typeof to === 'string') {
                    to = new UUID_1.UUID(to);
                }
                let typeTimer = null;
                this.startTypingIM(to).then(() => {
                    typeTimer = setInterval(() => {
                        this.startTypingIM(to).catch(() => {
                            // ignore
                        });
                    }, 5000);
                    if (charactersPerSecond === undefined) {
                        charactersPerSecond = 5;
                    }
                    const timeToWait = (message.length / charactersPerSecond) * 1000;
                    setTimeout(() => {
                        if (typeTimer !== null) {
                            clearInterval(typeTimer);
                            typeTimer = null;
                        }
                        this.stopTypingIM(to).then(() => {
                            this.sendInstantMessage(to, message).then(() => {
                                resolve();
                            }).catch((err) => {
                                reject(err);
                            });
                        }).catch((err) => {
                            reject(err);
                        });
                    }, timeToWait);
                }).catch((err) => {
                    if (typeTimer !== null) {
                        clearInterval(typeTimer);
                        typeTimer = null;
                    }
                    reject(err);
                });
            }, thinkingTime);
        });
    }
    typeLocalMessage(message, thinkingTime, charactersPerSecond) {
        return new Promise((resolve, reject) => {
            if (thinkingTime === undefined) {
                thinkingTime = 0;
            }
            setTimeout(() => {
                this.startTypingLocal().then(() => {
                    this.bot.clientCommands.agent.startAnimations([new UUID_1.UUID('c541c47f-e0c0-058b-ad1a-d6ae3a4584d9')]).then(() => {
                        if (charactersPerSecond === undefined) {
                            charactersPerSecond = 5;
                        }
                        const timeToWait = (message.length / charactersPerSecond) * 1000;
                        setTimeout(() => {
                            this.stopTypingLocal().then(() => {
                                this.bot.clientCommands.agent.stopAnimations([new UUID_1.UUID('c541c47f-e0c0-058b-ad1a-d6ae3a4584d9')]).then(() => {
                                    this.say(message).then(() => {
                                        resolve();
                                    }).catch((err) => {
                                        reject(err);
                                    });
                                }).catch((err) => {
                                    reject(err);
                                });
                            }).catch((err) => {
                                reject(err);
                            });
                        }, timeToWait);
                    }).catch((err) => {
                        reject(err);
                    });
                }).catch((err) => {
                    reject(err);
                });
            }, thinkingTime);
        });
    }
    endGroupChatSession(groupID) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof groupID === 'string') {
                groupID = new UUID_1.UUID(groupID);
            }
            if (!this.agent.hasChatSession(groupID)) {
                throw new Error('Group session does not exist');
            }
            const circuit = this.circuit;
            const agentName = this.agent.firstName + ' ' + this.agent.lastName;
            const im = new ImprovedInstantMessage_1.ImprovedInstantMessageMessage();
            im.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: circuit.sessionID
            };
            im.MessageBlock = {
                FromGroup: false,
                ToAgentID: groupID,
                ParentEstateID: 0,
                RegionID: UUID_1.UUID.zero(),
                Position: Vector3_1.Vector3.getZero(),
                Offline: 0,
                Dialog: InstantMessageDialog_1.InstantMessageDialog.SessionDrop,
                ID: groupID,
                Timestamp: Math.floor(new Date().getTime() / 1000),
                FromAgentName: Utils_1.Utils.StringToBuffer(agentName),
                Message: Buffer.allocUnsafe(0),
                BinaryBucket: Buffer.allocUnsafe(0)
            };
            im.EstateBlock = {
                EstateID: 0
            };
            this.agent.deleteChatSession(groupID);
            const sequenceNo = this.circuit.sendMessage(im, PacketFlags_1.PacketFlags.Reliable);
            return this.circuit.waitForAck(sequenceNo, 10000);
        });
    }
    startGroupChatSession(groupID, message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof groupID === 'string') {
                groupID = new UUID_1.UUID(groupID);
            }
            if (this.agent.hasChatSession(groupID)) {
                return;
            }
            const circuit = this.circuit;
            const agentName = this.agent.firstName + ' ' + this.agent.lastName;
            const im = new ImprovedInstantMessage_1.ImprovedInstantMessageMessage();
            im.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: circuit.sessionID
            };
            im.MessageBlock = {
                FromGroup: false,
                ToAgentID: groupID,
                ParentEstateID: 0,
                RegionID: UUID_1.UUID.zero(),
                Position: Vector3_1.Vector3.getZero(),
                Offline: 0,
                Dialog: InstantMessageDialog_1.InstantMessageDialog.SessionGroupStart,
                ID: groupID,
                Timestamp: Math.floor(new Date().getTime() / 1000),
                FromAgentName: Utils_1.Utils.StringToBuffer(agentName),
                Message: Utils_1.Utils.StringToBuffer(message),
                BinaryBucket: Utils_1.Utils.StringToBuffer('')
            };
            im.EstateBlock = {
                EstateID: 0
            };
            circuit.sendMessage(im, PacketFlags_1.PacketFlags.Reliable);
            yield Utils_1.Utils.waitOrTimeOut(this.currentRegion.clientEvents.onGroupChatSessionJoin, 10000, (event) => {
                if (event.sessionID.toString() === groupID.toString()) {
                    return FilterResponse_1.FilterResponse.Finish;
                }
                return FilterResponse_1.FilterResponse.NoMatch;
            });
        });
    }
    moderateGroupChat(groupID, memberID, muteText, muteVoice) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof groupID === 'object') {
                groupID = groupID.toString();
            }
            if (typeof memberID === 'object') {
                memberID = memberID.toString();
            }
            yield this.startGroupChatSession(groupID, '');
            const requested = {
                'method': 'mute update',
                'params': {
                    'agent_id': new LLSD.UUID(memberID),
                    'mute_info': {
                        'voice': muteVoice,
                        'text': muteText
                    }
                },
                'session-id': new LLSD.UUID(groupID),
            };
            return this.currentRegion.caps.capsPostXML('ChatSessionRequest', requested);
        });
    }
    sendGroupMessage(groupID, message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof groupID === 'string') {
                groupID = new UUID_1.UUID(groupID);
            }
            if (!this.agent.hasChatSession(groupID)) {
                yield this.startGroupChatSession(groupID, message);
            }
            const circuit = this.circuit;
            const agentName = this.agent.firstName + ' ' + this.agent.lastName;
            const im = new ImprovedInstantMessage_1.ImprovedInstantMessageMessage();
            im.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: circuit.sessionID
            };
            im.MessageBlock = {
                FromGroup: false,
                ToAgentID: groupID,
                ParentEstateID: 0,
                RegionID: UUID_1.UUID.zero(),
                Position: Vector3_1.Vector3.getZero(),
                Offline: 0,
                Dialog: InstantMessageDialog_1.InstantMessageDialog.SessionSend,
                ID: groupID,
                Timestamp: Math.floor(new Date().getTime() / 1000),
                FromAgentName: Utils_1.Utils.StringToBuffer(agentName),
                Message: Utils_1.Utils.StringToBuffer(message),
                BinaryBucket: Utils_1.Utils.StringToBuffer('')
            };
            im.EstateBlock = {
                EstateID: 0
            };
            const sequenceNo = circuit.sendMessage(im, PacketFlags_1.PacketFlags.Reliable);
            yield this.circuit.waitForAck(sequenceNo, 10000);
            return this.bot.clientCommands.group.getSessionAgentCount(groupID);
        });
    }
    respondToScriptDialog(event, buttonIndex) {
        const dialog = new ScriptDialogReply_1.ScriptDialogReplyMessage();
        dialog.AgentData = {
            AgentID: this.agent.agentID,
            SessionID: this.circuit.sessionID
        };
        dialog.Data = {
            ObjectID: event.ObjectID,
            ChatChannel: event.ChatChannel,
            ButtonIndex: buttonIndex,
            ButtonLabel: Utils_1.Utils.StringToBuffer(event.Buttons[buttonIndex])
        };
        const sequenceNo = this.circuit.sendMessage(dialog, PacketFlags_1.PacketFlags.Reliable);
        return this.circuit.waitForAck(sequenceNo, 10000);
    }
}
exports.CommunicationsCommands = CommunicationsCommands;
//# sourceMappingURL=CommunicationsCommands.js.map