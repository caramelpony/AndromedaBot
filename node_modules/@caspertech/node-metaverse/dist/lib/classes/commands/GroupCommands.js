"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupCommands = void 0;
const CommandsBase_1 = require("./CommandsBase");
const UUID_1 = require("../UUID");
const InstantMessageDialog_1 = require("../../enums/InstantMessageDialog");
const Utils_1 = require("../Utils");
const PacketFlags_1 = require("../../enums/PacketFlags");
const ImprovedInstantMessage_1 = require("../messages/ImprovedInstantMessage");
const Vector3_1 = require("../Vector3");
const InviteGroupRequest_1 = require("../messages/InviteGroupRequest");
const GroupRole_1 = require("../GroupRole");
const GroupRoleDataRequest_1 = require("../messages/GroupRoleDataRequest");
const Message_1 = require("../../enums/Message");
const GroupMember_1 = require("../GroupMember");
const FilterResponse_1 = require("../../enums/FilterResponse");
const LLSD = require("@caspertech/llsd");
const EjectGroupMemberRequest_1 = require("../messages/EjectGroupMemberRequest");
const GroupProfileRequest_1 = require("../messages/GroupProfileRequest");
const GroupBanAction_1 = require("../../enums/GroupBanAction");
const GroupBan_1 = require("../GroupBan");
class GroupCommands extends CommandsBase_1.CommandsBase {
    sendGroupNotice(groupID, subject, message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof groupID === 'string') {
                groupID = new UUID_1.UUID(groupID);
            }
            const circuit = this.circuit;
            const agentName = this.agent.firstName + ' ' + this.agent.lastName;
            const im = new ImprovedInstantMessage_1.ImprovedInstantMessageMessage();
            im.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: circuit.sessionID
            };
            im.MessageBlock = {
                FromGroup: false,
                ToAgentID: groupID,
                ParentEstateID: 0,
                RegionID: UUID_1.UUID.zero(),
                Position: Vector3_1.Vector3.getZero(),
                Offline: 0,
                Dialog: InstantMessageDialog_1.InstantMessageDialog.GroupNotice,
                ID: UUID_1.UUID.zero(),
                Timestamp: 0,
                FromAgentName: Utils_1.Utils.StringToBuffer(agentName),
                Message: Utils_1.Utils.StringToBuffer(subject + '|' + message),
                BinaryBucket: Buffer.allocUnsafe(0)
            };
            im.EstateBlock = {
                EstateID: 0
            };
            const sequenceNo = circuit.sendMessage(im, PacketFlags_1.PacketFlags.Reliable);
            return yield circuit.waitForAck(sequenceNo, 10000);
        });
    }
    sendGroupInviteBulk(groupID, sendTo) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof groupID === 'string') {
                groupID = new UUID_1.UUID(groupID);
            }
            const igr = new InviteGroupRequest_1.InviteGroupRequestMessage();
            igr.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: this.circuit.sessionID
            };
            igr.GroupData = {
                GroupID: groupID
            };
            igr.InviteData = [];
            for (const to of sendTo) {
                if (typeof to.avatarID === 'string') {
                    to.avatarID = new UUID_1.UUID(to.avatarID);
                }
                if (to.roleID === undefined) {
                    to.roleID = UUID_1.UUID.zero();
                }
                if (typeof to.roleID === 'string') {
                    to.roleID = new UUID_1.UUID(to.roleID);
                }
                igr.InviteData.push({
                    InviteeID: to.avatarID,
                    RoleID: to.roleID
                });
            }
            const sequenceNo = this.circuit.sendMessage(igr, PacketFlags_1.PacketFlags.Reliable);
            return yield this.circuit.waitForAck(sequenceNo, 10000);
        });
    }
    getSessionAgentCount(sessionID) {
        if (typeof sessionID === 'string') {
            sessionID = new UUID_1.UUID(sessionID);
        }
        return this.agent.getSessionAgentCount(sessionID);
    }
    sendGroupInvite(groupID, to, role) {
        return __awaiter(this, void 0, void 0, function* () {
            const sendTo = [{
                    avatarID: to,
                    roleID: role
                }];
            return yield this.sendGroupInviteBulk(groupID, sendTo);
        });
    }
    acceptGroupInvite(event) {
        return __awaiter(this, void 0, void 0, function* () {
            const circuit = this.circuit;
            const agentName = this.agent.firstName + ' ' + this.agent.lastName;
            const im = new ImprovedInstantMessage_1.ImprovedInstantMessageMessage();
            im.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: circuit.sessionID
            };
            im.MessageBlock = {
                FromGroup: false,
                ToAgentID: event.from,
                ParentEstateID: 0,
                RegionID: UUID_1.UUID.zero(),
                Position: Vector3_1.Vector3.getZero(),
                Offline: 0,
                Dialog: InstantMessageDialog_1.InstantMessageDialog.GroupInvitationAccept,
                ID: event.inviteID,
                Timestamp: Math.floor(new Date().getTime() / 1000),
                FromAgentName: Utils_1.Utils.StringToBuffer(agentName),
                Message: Utils_1.Utils.StringToBuffer(''),
                BinaryBucket: Buffer.allocUnsafe(0)
            };
            im.EstateBlock = {
                EstateID: 0
            };
            const sequenceNo = circuit.sendMessage(im, PacketFlags_1.PacketFlags.Reliable);
            return yield circuit.waitForAck(sequenceNo, 10000);
        });
    }
    rejectGroupInvite(event) {
        return __awaiter(this, void 0, void 0, function* () {
            const circuit = this.circuit;
            const agentName = this.agent.firstName + ' ' + this.agent.lastName;
            const im = new ImprovedInstantMessage_1.ImprovedInstantMessageMessage();
            im.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: circuit.sessionID
            };
            im.MessageBlock = {
                FromGroup: false,
                ToAgentID: event.from,
                ParentEstateID: 0,
                RegionID: UUID_1.UUID.zero(),
                Position: Vector3_1.Vector3.getZero(),
                Offline: 0,
                Dialog: InstantMessageDialog_1.InstantMessageDialog.GroupInvitationDecline,
                ID: event.inviteID,
                Timestamp: Math.floor(new Date().getTime() / 1000),
                FromAgentName: Utils_1.Utils.StringToBuffer(agentName),
                Message: Utils_1.Utils.StringToBuffer(''),
                BinaryBucket: Buffer.allocUnsafe(0)
            };
            im.EstateBlock = {
                EstateID: 0
            };
            const sequenceNo = circuit.sendMessage(im, PacketFlags_1.PacketFlags.Reliable);
            return yield circuit.waitForAck(sequenceNo, 10000);
        });
    }
    unbanMembers(groupID, avatars) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.banMembers(groupID, avatars, GroupBanAction_1.GroupBanAction.Unban);
        });
    }
    banMembers(groupID, avatars, groupAction = GroupBanAction_1.GroupBanAction.Ban) {
        return __awaiter(this, void 0, void 0, function* () {
            const listOfIDs = [];
            if (typeof groupID === 'string') {
                groupID = new UUID_1.UUID(groupID);
            }
            if (Array.isArray(avatars)) {
                for (const av of avatars) {
                    if (typeof av === 'string') {
                        listOfIDs.push(av);
                    }
                    else {
                        listOfIDs.push(av.toString());
                    }
                }
            }
            else if (typeof avatars === 'string') {
                listOfIDs.push(avatars);
            }
            else {
                listOfIDs.push(avatars.toString());
            }
            const requestData = {
                'ban_action': groupAction,
                'ban_ids': []
            };
            for (const id of listOfIDs) {
                requestData.ban_ids.push(new LLSD.UUID(id));
            }
            yield this.currentRegion.caps.capsPostXML(['GroupAPIv1', { 'group_id': groupID.toString() }], requestData);
        });
    }
    getBanList(groupID) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof groupID === 'string') {
                groupID = new UUID_1.UUID(groupID);
            }
            const result = yield this.currentRegion.caps.capsGetXML(['GroupAPIv1', { 'group_id': groupID.toString() }]);
            const bans = [];
            if (result.ban_list !== undefined) {
                for (const k of Object.keys(result.ban_list)) {
                    bans.push(new GroupBan_1.GroupBan(new UUID_1.UUID(k), result.ban_list[k].ban_date));
                }
            }
            return bans;
        });
    }
    getMemberList(groupID) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof groupID === 'string') {
                groupID = new UUID_1.UUID(groupID);
            }
            const result = [];
            const requestData = {
                'group_id': new LLSD.UUID(groupID.toString())
            };
            const response = yield this.currentRegion.caps.capsPostXML('GroupMemberData', requestData);
            if (response['members']) {
                for (const uuid of Object.keys(response['members'])) {
                    const member = new GroupMember_1.GroupMember();
                    const data = response['members'][uuid];
                    member.AgentID = new UUID_1.UUID(uuid);
                    member.OnlineStatus = data['last_login'];
                    let powers = response['defaults']['default_powers'];
                    if (data['powers']) {
                        powers = data['powers'];
                    }
                    member.IsOwner = data['owner'] === 'Y';
                    let titleIndex = 0;
                    if (data['title']) {
                        titleIndex = data['title'];
                    }
                    member.Title = response['titles'][titleIndex];
                    member.AgentPowers = Utils_1.Utils.HexToLong(powers);
                    result.push(member);
                }
                return result;
            }
            else {
                throw new Error('Bad response');
            }
        });
    }
    getGroupRoles(groupID) {
        return new Promise((resolve, reject) => {
            const result = [];
            if (typeof groupID === 'string') {
                groupID = new UUID_1.UUID(groupID);
            }
            const grdr = new GroupRoleDataRequest_1.GroupRoleDataRequestMessage();
            grdr.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: this.circuit.sessionID
            };
            const requestID = UUID_1.UUID.random();
            grdr.GroupData = {
                GroupID: groupID,
                RequestID: requestID
            };
            let totalRoleCount = 0;
            this.circuit.sendMessage(grdr, PacketFlags_1.PacketFlags.Reliable);
            this.circuit.waitForMessage(Message_1.Message.GroupRoleDataReply, 10000, (gmr) => {
                if (gmr.GroupData.RequestID.toString() === requestID.toString()) {
                    totalRoleCount = gmr.GroupData.RoleCount;
                    for (const role of gmr.RoleData) {
                        const gr = new GroupRole_1.GroupRole();
                        gr.RoleID = role.RoleID;
                        gr.Name = Utils_1.Utils.BufferToStringSimple(role.Name);
                        gr.Title = Utils_1.Utils.BufferToStringSimple(role.Title);
                        gr.Description = Utils_1.Utils.BufferToStringSimple(role.Description);
                        gr.Powers = role.Powers;
                        gr.Members = role.Members;
                        result.push(gr);
                    }
                    if (totalRoleCount > result.length) {
                        return FilterResponse_1.FilterResponse.Match;
                    }
                    else {
                        return FilterResponse_1.FilterResponse.Finish;
                    }
                }
                else {
                    return FilterResponse_1.FilterResponse.NoMatch;
                }
            }).then(() => {
                resolve(result);
            }).catch((err) => {
                if (result.length === 0) {
                    reject(err);
                }
                else {
                    resolve(err);
                }
            });
        });
    }
    ejectFromGroupBulk(groupID, sendTo) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof groupID === 'string') {
                groupID = new UUID_1.UUID(groupID);
            }
            const msg = new EjectGroupMemberRequest_1.EjectGroupMemberRequestMessage();
            msg.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: this.circuit.sessionID
            };
            msg.GroupData = {
                GroupID: groupID
            };
            msg.EjectData = [];
            for (let ejecteeID of sendTo) {
                if (typeof ejecteeID === 'string') {
                    ejecteeID = new UUID_1.UUID(ejecteeID);
                }
                msg.EjectData.push({
                    EjecteeID: ejecteeID
                });
            }
            ;
            const sequenceNo = this.circuit.sendMessage(msg, PacketFlags_1.PacketFlags.Reliable);
            return yield this.circuit.waitForAck(sequenceNo, 10000);
        });
    }
    ejectFromGroup(groupID, ejecteeID) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof ejecteeID === 'string') {
                ejecteeID = new UUID_1.UUID(ejecteeID);
            }
            const sendTo = [ejecteeID];
            return yield this.ejectFromGroupBulk(groupID, sendTo);
        });
    }
    getGroupProfile(groupID) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof groupID === 'string') {
                groupID = new UUID_1.UUID(groupID);
            }
            const msg = new GroupProfileRequest_1.GroupProfileRequestMessage();
            msg.AgentData = {
                AgentID: this.agent.agentID,
                SessionID: this.circuit.sessionID
            };
            msg.GroupData = {
                GroupID: groupID
            };
            this.circuit.sendMessage(msg, PacketFlags_1.PacketFlags.Reliable);
            const groupProfileReply = (yield this.circuit.waitForMessage(Message_1.Message.GroupProfileReply, 10000, (packet) => {
                const replyMessage = packet;
                if (replyMessage.GroupData.GroupID.equals(groupID)) {
                    console.log('groupProfileReply Finish');
                    return FilterResponse_1.FilterResponse.Finish;
                }
                console.log('groupProfileReply NoMatch');
                return FilterResponse_1.FilterResponse.NoMatch;
            }));
            return new class {
                constructor() {
                    this.GroupID = groupProfileReply.GroupData.GroupID;
                    this.Name = Utils_1.Utils.BufferToStringSimple(groupProfileReply.GroupData.Name);
                    this.Charter = Utils_1.Utils.BufferToStringSimple(groupProfileReply.GroupData.Charter);
                    this.ShowInList = groupProfileReply.GroupData.ShowInList;
                    this.MemberTitle = Utils_1.Utils.BufferToStringSimple(groupProfileReply.GroupData.MemberTitle);
                    this.PowersMask = groupProfileReply.GroupData.PowersMask;
                    this.InsigniaID = groupProfileReply.GroupData.InsigniaID;
                    this.FounderID = groupProfileReply.GroupData.FounderID;
                    this.MembershipFee = groupProfileReply.GroupData.MembershipFee;
                    this.OpenEnrollment = groupProfileReply.GroupData.OpenEnrollment;
                    this.Money = groupProfileReply.GroupData.Money;
                    this.GroupMembershipCount = groupProfileReply.GroupData.GroupMembershipCount;
                    this.GroupRolesCount = groupProfileReply.GroupData.GroupRolesCount;
                    this.AllowPublish = groupProfileReply.GroupData.AllowPublish;
                    this.MaturePublish = groupProfileReply.GroupData.MaturePublish;
                    this.OwnerRole = groupProfileReply.GroupData.OwnerRole;
                }
            };
        });
    }
}
exports.GroupCommands = GroupCommands;
//# sourceMappingURL=GroupCommands.js.map