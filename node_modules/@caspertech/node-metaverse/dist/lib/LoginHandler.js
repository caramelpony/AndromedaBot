"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoginHandler = void 0;
const validator_1 = require("validator");
const xmlrpc = require("xmlrpc");
const fs = require("fs");
const path = require("path");
const LoginError_1 = require("./classes/LoginError");
const LoginResponse_1 = require("./classes/LoginResponse");
const Utils_1 = require("./classes/Utils");
const UUID_1 = require("./classes/UUID");
const url_1 = require("url");
class LoginHandler {
    constructor(ce, options) {
        this.clientEvents = ce;
        this.options = options;
    }
    Login(params) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const loginURI = new url_1.URL(params.url);
            let secure = false;
            if (loginURI.protocol !== null && loginURI.protocol.trim().toLowerCase() === 'https:') {
                secure = true;
            }
            let port = loginURI.port;
            if (port === null) {
                port = secure ? '443' : '80';
            }
            const secureClientOptions = {
                host: loginURI.hostname || undefined,
                port: parseInt(port, 10),
                path: loginURI.pathname || undefined,
                rejectUnauthorized: false,
                timeout: 60000
            };
            const viewerDigest = 'ce50e500-e6f0-15ab-4b9d-0591afb91ffe';
            const client = (secure) ? xmlrpc.createSecureClient(secureClientOptions) : xmlrpc.createClient(secureClientOptions);
            const nameHash = Utils_1.Utils.SHA1String(params.firstName + params.lastName + viewerDigest);
            const macAddress = [];
            for (let i = 0; i < 12; i = i + 2) {
                macAddress.push(nameHash.substr(i, 2));
            }
            let hardwareID = null;
            const hardwareIDFile = path.resolve(__dirname, 'deviceToken.json');
            try {
                const hwID = yield fs.promises.readFile(hardwareIDFile);
                const data = JSON.parse(hwID.toString('utf-8'));
                hardwareID = data.id0;
            }
            catch (e) {
                // Ignore any error
            }
            if (hardwareID === null || !validator_1.default.isUUID(String(hardwareID))) {
                hardwareID = UUID_1.UUID.random().toString();
                yield fs.promises.writeFile(hardwareIDFile, JSON.stringify({ id0: hardwareID }));
            }
            const mfaToken = (_a = params.token) !== null && _a !== void 0 ? _a : '';
            const mfaHash = (_b = params.mfa_hash) !== null && _b !== void 0 ? _b : '';
            return new Promise((resolve, reject) => {
                let password = params.password;
                if (params.getHashedPassword) {
                    password = params.getHashedPassword();
                }
                client.methodCall('login_to_simulator', [
                    {
                        'first': params.firstName,
                        'last': params.lastName,
                        'passwd': password,
                        'start': params.start,
                        'major': '0',
                        'minor': '0',
                        'patch': '1',
                        'build': '0',
                        'platform': 'win',
                        'token': mfaToken,
                        'mfa_hash': mfaHash,
                        'id0': hardwareID,
                        'mac': macAddress.join(':'),
                        'viewer_digest': viewerDigest,
                        'user_agent': 'node-metaverse',
                        'author': 'nmv@caspertech.co.uk',
                        'agree_to_tos': params.agreeToTOS,
                        'read_critical': params.readCritical,
                        'options': [
                            'inventory-root',
                            'inventory-skeleton',
                            'inventory-lib-root',
                            'inventory-lib-owner',
                            'inventory-skel-lib',
                            'gestures',
                            'event_categories',
                            'event_notifications',
                            'classified_categories',
                            'buddy-list',
                            'ui-config',
                            'login-flags',
                            'global-textures'
                        ]
                    }
                ], (error, value) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        if (!value['login'] || value['login'] === 'false') {
                            reject(new LoginError_1.LoginError(value));
                        }
                        else {
                            const response = new LoginResponse_1.LoginResponse(value, this.clientEvents, this.options);
                            resolve(response);
                        }
                    }
                });
            });
        });
    }
}
exports.LoginHandler = LoginHandler;
//# sourceMappingURL=LoginHandler.js.map