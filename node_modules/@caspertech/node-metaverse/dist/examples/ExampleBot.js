"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExampleBot = void 0;
const Bot_1 = require("../lib/Bot");
const BotOptionFlags_1 = require("../lib/enums/BotOptionFlags");
const path = require("path");
class ExampleBot {
    constructor() {
        this.masterAvatar = 'd1cd5b71-6209-4595-9bf0-771bf689ce00';
        this.isConnected = false;
        this.isConnecting = false;
        this.loginParamsJsonFile = path.join(__dirname, '..', '..', 'examples', 'loginParameters.json');
        this.loginParameters = require(this.loginParamsJsonFile);
        this.firstName = this.loginParameters.firstName;
        this.lastName = this.loginParameters.lastName;
        // If you don't intend to use the object store (i.e you have no interest in inworld objects, textures, etc,
        // using nmv.BotOptionFlags.LiteObjectStore will drastically reduce the footprint and CPU usage.
        //
        // The full object store has a full searchable rtree index, the lite does not.
        //
        // For the minimum footprint, use :
        //
        // const options = nmv.BotOptionFlags.LiteObjectStore | nmv.BotOptionFlags.StoreMyAttachmentsOnly;
        const options = BotOptionFlags_1.BotOptionFlags.None;
        this.bot = new Bot_1.Bot(this.loginParameters, options);
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            const exitHandler = (options, err) => __awaiter(this, void 0, void 0, function* () {
                if (err && err instanceof Error) {
                    console.log(err.stack);
                }
                if (this.isConnected) {
                    console.log('Disconnecting');
                    try {
                        yield this.bot.close();
                    }
                    catch (error) {
                        console.error('Error when closing client:');
                        console.error(error);
                    }
                    process.exit();
                    return;
                }
                if (options.exit) {
                    process.exit();
                }
            });
            // Do something when app is closing
            process.on('exit', exitHandler.bind(this, {}));
            // Catches ctrl+c event
            process.on('SIGINT', exitHandler.bind(this, { exit: true }));
            // Catches "kill pid"
            process.on('SIGUSR1', exitHandler.bind(this, { exit: true }));
            process.on('SIGUSR2', exitHandler.bind(this, { exit: true }));
            // Catches uncaught exceptions
            process.on('uncaughtException', exitHandler.bind(this, { exit: true }));
            // This will tell the bot to keep trying to teleport back to the 'stay' location.
            // You can specify a region and position, such as:
            // bot.stayPut(true, 'Izanagi', new nmv.Vector3([128, 128, 21]));
            // Note that the 'stay' location will be updated if you request or accept a lure (a teleport).
            // If no region is specified, it will be set to the region you log in to.
            this.bot.stayPut(true, this.stayRegion, this.stayPosition);
            yield this.login();
        });
    }
    onConnected() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    login() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isConnecting) {
                return;
            }
            this.isConnecting = true;
            try {
                if (this.reconnectTimer !== undefined) {
                    clearInterval(this.reconnectTimer);
                }
                this.reconnectTimer = setInterval(this.reconnectCheck.bind(this), 60000);
                console.log('Logging in..');
                this.loginResponse = yield this.bot.login();
                console.log('Login complete');
                // Establish circuit with region
                yield this.bot.connectToSim();
                console.log('Waiting for event queue');
                yield this.bot.waitForEventQueue();
                this.isConnected = true;
            }
            finally {
                this.isConnecting = false;
            }
            return this.connected();
        });
    }
    reconnectCheck() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isConnected) {
                yield this.login();
            }
        });
    }
    connected() {
        return __awaiter(this, void 0, void 0, function* () {
            this.bot.clientEvents.onDisconnected.subscribe((event) => {
                if (event.requested) {
                    if (this.reconnectTimer !== undefined) {
                        clearInterval(this.reconnectTimer);
                    }
                }
                this.isConnected = false;
                console.log('Disconnected from simulator: ' + event.message);
            });
            yield this.onConnected();
        });
    }
    // @ts-ignore
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.reconnectTimer !== undefined) {
                clearInterval(this.reconnectTimer);
                this.reconnectTimer = undefined;
            }
            return this.bot.close();
        });
    }
}
exports.ExampleBot = ExampleBot;
//# sourceMappingURL=ExampleBot.js.map